(Add(Ptr|32|16|8) ...) => (ADDL ...)
(Add(32|64)F ...) => (ADDS(S|D) ...)
(Add32carry ...) => (ADDLcarry ...)
(Add32withcarry ...) => (ADCL ...)
(Sub(Ptr|32|16|8) ...) => (SUBL ...)
(Sub(32|64)F ...) => (SUBS(S|D) ...)
(Sub32carry ...) => (SUBLcarry ...)
(Sub32withcarry ...) => (SBBL ...)
(Mul(32|16|8) ...) => (MULL ...)
(Mul(32|64)F ...) => (MULS(S|D) ...)
(Mul32uhilo ...) => (MULLQU ...)
(Select0 (Mul32uover x y)) => (Select0 <typ.UInt32> (MULLU x y))
(Select1 (Mul32uover x y)) => (SETO (Select1 <types.TypeFlags> (MULLU x y)))
(Avg32u ...) => (AVGLU ...)
(Div(32|64)F ...) => (DIVS(S|D) ...)
(Div(32|32u|16|16u) ...) => (DIV(L|LU|W|WU) ...)
(Div8 x y) => (DIVW (SignExt8to16 x) (SignExt8to16 y))
(Div8u x y) => (DIVWU (ZeroExt8to16 x) (ZeroExt8to16 y))
(Hmul(32|32u) ...) => (HMUL(L|LU) ...)
(Mod(32|32u|16|16u) ...) => (MOD(L|LU|W|WU) ...)
(Mod8 x y) => (MODW (SignExt8to16 x) (SignExt8to16 y))
(Mod8u x y) => (MODWU (ZeroExt8to16 x) (ZeroExt8to16 y))
(And(32|16|8) ...) => (ANDL ...)
(Or(32|16|8) ...) => (ORL ...)
(Xor(32|16|8) ...) => (XORL ...)
(Neg(32|16|8) ...) => (NEGL ...)
(Neg32F x) => (PXOR x (MOVSSconst <typ.Float32> [float32(math.Copysign(0, -1))]))
(Neg64F x) => (PXOR x (MOVSDconst <typ.Float64> [math.Copysign(0, -1)]))
(Com(32|16|8) ...) => (NOTL ...)
(AndB ...) => (ANDL ...)
(OrB ...) => (ORL ...)
(Not x) => (XORLconst [1] x)
(OffPtr [off] ptr) => (ADDLconst [int32(off)] ptr)
(Bswap32 ...) => (BSWAPL ...)
(Sqrt ...) => (SQRTSD ...)
(Ctz16 x) => (BSFL (ORLconst <typ.UInt32> [0x10000] x))
(Ctz16NonZero ...) => (BSFL ...)
(SignExt8to16 ...) => (MOVBLSX ...)
(SignExt8to32 ...) => (MOVBLSX ...)
(SignExt16to32 ...) => (MOVWLSX ...)
(ZeroExt8to16 ...) => (MOVBLZX ...)
(ZeroExt8to32 ...) => (MOVBLZX ...)
(ZeroExt16to32 ...) => (MOVWLZX ...)
(Signmask x) => (SARLconst [31] x)
(Zeromask <t> x) => (XORLconst [-1] (SBBLcarrymask <t> (CMPLconst [1] x)))
(Slicemask <t> x) => (SARLconst [31] (NEGL <t> x))
(Trunc16to8 ...) => (Copy ...)
(Trunc32to8 ...) => (Copy ...)
(Trunc32to16 ...) => (Copy ...)
(Cvt32to32F ...) => (CVTSL2SS ...)
(Cvt32to64F ...) => (CVTSL2SD ...)
(Cvt32Fto32 ...) => (CVTTSS2SL ...)
(Cvt64Fto32 ...) => (CVTTSD2SL ...)
(Cvt32Fto64F ...) => (CVTSS2SD ...)
(Cvt64Fto32F ...) => (CVTSD2SS ...)
(Round32F ...) => (Copy ...)
(Round64F ...) => (Copy ...)
(CvtBoolToUint8 ...) => (Copy ...)
(Lsh32x(32|16|8) <t> x y) && !shiftIsBounded(v) => (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMP(L|W|B)const [32] y)))
(Lsh16x(32|16|8) <t> x y) && !shiftIsBounded(v) => (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMP(L|W|B)const [32] y)))
(Lsh8x(32|16|8) <t> x y) && !shiftIsBounded(v) => (ANDL (SHLL <t> x y) (SBBLcarrymask <t> (CMP(L|W|B)const [32] y)))
(Lsh32x(32|16|8) <t> x y) && shiftIsBounded(v) => (SHLL <t> x y)
(Lsh16x(32|16|8) <t> x y) && shiftIsBounded(v) => (SHLL <t> x y)
(Lsh8x(32|16|8) <t> x y) && shiftIsBounded(v) => (SHLL <t> x y)
(Rsh32Ux(32|16|8) <t> x y) && !shiftIsBounded(v) => (ANDL (SHRL <t> x y) (SBBLcarrymask <t> (CMP(L|W|B)const [32] y)))
(Rsh16Ux(32|16|8) <t> x y) && !shiftIsBounded(v) => (ANDL (SHRW <t> x y) (SBBLcarrymask <t> (CMP(L|W|B)const [16] y)))
(Rsh8Ux(32|16|8) <t> x y) && !shiftIsBounded(v) => (ANDL (SHRB <t> x y) (SBBLcarrymask <t> (CMP(L|W|B)const [8] y)))
(Rsh32Ux(32|16|8) <t> x y) && shiftIsBounded(v) => (SHRL <t> x y)
(Rsh16Ux(32|16|8) <t> x y) && shiftIsBounded(v) => (SHRW <t> x y)
(Rsh8Ux(32|16|8) <t> x y) && shiftIsBounded(v) => (SHRB <t> x y)
(Rsh32x(32|16|8) <t> x y) && !shiftIsBounded(v) => (SARL <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMP(L|W|B)const [32] y)))))
(Rsh16x(32|16|8) <t> x y) && !shiftIsBounded(v) => (SARW <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMP(L|W|B)const [16] y)))))
(Rsh8x(32|16|8) <t> x y) && !shiftIsBounded(v) => (SARB <t> x (ORL <y.Type> y (NOTL <y.Type> (SBBLcarrymask <y.Type> (CMP(L|W|B)const [8] y)))))
(Rsh32x(32|16|8) <t> x y) && shiftIsBounded(v) => (SARL x y)
(Rsh16x(32|16|8) <t> x y) && shiftIsBounded(v) => (SARW x y)
(Rsh8x(32|16|8) <t> x y) && shiftIsBounded(v) => (SARB x y)
(Lsh32x64 x (Const64 [c])) && uint64(c) < 32 => (SHLLconst [int32(c)] x)
(Rsh32x64 x (Const64 [c])) && uint64(c) < 32 => (SARLconst [int32(c)] x)
(Rsh32Ux64 x (Const64 [c])) && uint64(c) < 32 => (SHRLconst [int32(c)] x)
(Lsh16x64 x (Const64 [c])) && uint64(c) < 16 => (SHLLconst [int32(c)] x)
(Rsh16x64 x (Const64 [c])) && uint64(c) < 16 => (SARWconst [int16(c)] x)
(Rsh16Ux64 x (Const64 [c])) && uint64(c) < 16 => (SHRWconst [int16(c)] x)
(Lsh8x64 x (Const64 [c])) && uint64(c) < 8 => (SHLLconst [int32(c)] x)
(Rsh8x64 x (Const64 [c])) && uint64(c) < 8 => (SARBconst [int8(c)] x)
(Rsh8Ux64 x (Const64 [c])) && uint64(c) < 8 => (SHRBconst [int8(c)] x)
(Lsh32x64 _ (Const64 [c])) && uint64(c) >= 32 => (Const32 [0])
(Rsh32Ux64 _ (Const64 [c])) && uint64(c) >= 32 => (Const32 [0])
(Lsh16x64 _ (Const64 [c])) && uint64(c) >= 16 => (Const16 [0])
(Rsh16Ux64 _ (Const64 [c])) && uint64(c) >= 16 => (Const16 [0])
(Lsh8x64 _ (Const64 [c])) && uint64(c) >= 8 => (Const8 [0])
(Rsh8Ux64 _ (Const64 [c])) && uint64(c) >= 8 => (Const8 [0])
(Rsh32x64 x (Const64 [c])) && uint64(c) >= 32 => (SARLconst [31] x)
(Rsh16x64 x (Const64 [c])) && uint64(c) >= 16 => (SARWconst [15] x)
(Rsh8x64 x (Const64 [c])) && uint64(c) >= 8 => (SARBconst [7] x)
(RotateLeft32 x (MOVLconst [c])) => (ROLLconst [c&31] x)
(RotateLeft16 x (MOVLconst [c])) => (ROLWconst [int16(c&15)] x)
(RotateLeft8 x (MOVLconst [c])) => (ROLBconst [int8(c&7)] x)
(Less32 x y) => (SETL (CMPL x y))
(Less16 x y) => (SETL (CMPW x y))
(Less8 x y) => (SETL (CMPB x y))
(Less32U x y) => (SETB (CMPL x y))
(Less16U x y) => (SETB (CMPW x y))
(Less8U x y) => (SETB (CMPB x y))
(Less64F x y) => (SETGF (UCOMISD y x))
(Less32F x y) => (SETGF (UCOMISS y x))
(Leq32 x y) => (SETLE (CMPL x y))
(Leq16 x y) => (SETLE (CMPW x y))
(Leq8 x y) => (SETLE (CMPB x y))
(Leq32U x y) => (SETBE (CMPL x y))
(Leq16U x y) => (SETBE (CMPW x y))
(Leq8U x y) => (SETBE (CMPB x y))
(Leq64F x y) => (SETGEF (UCOMISD y x))
(Leq32F x y) => (SETGEF (UCOMISS y x))
(Eq32 x y) => (SETEQ (CMPL x y))
(Eq16 x y) => (SETEQ (CMPW x y))
(Eq8 x y) => (SETEQ (CMPB x y))
(EqB x y) => (SETEQ (CMPB x y))
(EqPtr x y) => (SETEQ (CMPL x y))
(Eq64F x y) => (SETEQF (UCOMISD x y))
(Eq32F x y) => (SETEQF (UCOMISS x y))
(Neq32 x y) => (SETNE (CMPL x y))
(Neq16 x y) => (SETNE (CMPW x y))
(Neq8 x y) => (SETNE (CMPB x y))
(NeqB x y) => (SETNE (CMPB x y))
(NeqPtr x y) => (SETNE (CMPL x y))
(Neq64F x y) => (SETNEF (UCOMISD x y))
(Neq32F x y) => (SETNEF (UCOMISS x y))
(Load <t> ptr mem) && (is32BitInt(t) || isPtr(t)) => (MOVLload ptr mem)
(Load <t> ptr mem) && is16BitInt(t) => (MOVWload ptr mem)
(Load <t> ptr mem) && (t.IsBoolean() || is8BitInt(t)) => (MOVBload ptr mem)
(Load <t> ptr mem) && is32BitFloat(t) => (MOVSSload ptr mem)
(Load <t> ptr mem) && is64BitFloat(t) => (MOVSDload ptr mem)
(Store {t} ptr val mem) && t.Size() == 8 && is64BitFloat(val.Type) => (MOVSDstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 4 && is32BitFloat(val.Type) => (MOVSSstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 4 => (MOVLstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 2 => (MOVWstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 1 => (MOVBstore ptr val mem)
(Move [0] _ _ mem) => mem
(Move [1] dst src mem) => (MOVBstore dst (MOVBload src mem) mem)
(Move [2] dst src mem) => (MOVWstore dst (MOVWload src mem) mem)
(Move [4] dst src mem) => (MOVLstore dst (MOVLload src mem) mem)
(Move [3] dst src mem) => (MOVBstore [2] dst (MOVBload [2] src mem) (MOVWstore dst (MOVWload src mem) mem))
(Move [5] dst src mem) => (MOVBstore [4] dst (MOVBload [4] src mem) (MOVLstore dst (MOVLload src mem) mem))
(Move [6] dst src mem) => (MOVWstore [4] dst (MOVWload [4] src mem) (MOVLstore dst (MOVLload src mem) mem))
(Move [7] dst src mem) => (MOVLstore [3] dst (MOVLload [3] src mem) (MOVLstore dst (MOVLload src mem) mem))
(Move [8] dst src mem) => (MOVLstore [4] dst (MOVLload [4] src mem) (MOVLstore dst (MOVLload src mem) mem))
(Move [s] dst src mem) && s > 8 && s%4 != 0 => (Move [s-s%4] (ADDLconst <dst.Type> [int32(s%4)] dst) (ADDLconst <src.Type> [int32(s%4)] src) (MOVLstore dst (MOVLload src mem) mem))
(Move [s] dst src mem) && s > 8 && s <= 4*128 && s%4 == 0 && !config.noDuffDevice && logLargeCopy(v, s) => (DUFFCOPY [10*(128-s/4)] dst src mem)
(Move [s] dst src mem) && (s > 4*128 || config.noDuffDevice) && s%4 == 0 && logLargeCopy(v, s) => (REPMOVSL dst src (MOVLconst [int32(s/4)]) mem)
(Zero [0] _ mem) => mem
(Zero [1] destptr mem) => (MOVBstoreconst [0] destptr mem)
(Zero [2] destptr mem) => (MOVWstoreconst [0] destptr mem)
(Zero [4] destptr mem) => (MOVLstoreconst [0] destptr mem)
(Zero [3] destptr mem) => (MOVBstoreconst [makeValAndOff32(0, 2)] destptr (MOVWstoreconst [makeValAndOff32(0, 0)] destptr mem))
(Zero [5] destptr mem) => (MOVBstoreconst [makeValAndOff32(0, 4)] destptr (MOVLstoreconst [makeValAndOff32(0, 0)] destptr mem))
(Zero [6] destptr mem) => (MOVWstoreconst [makeValAndOff32(0, 4)] destptr (MOVLstoreconst [makeValAndOff32(0, 0)] destptr mem))
(Zero [7] destptr mem) => (MOVLstoreconst [makeValAndOff32(0, 3)] destptr (MOVLstoreconst [makeValAndOff32(0, 0)] destptr mem))
(Zero [s] destptr mem) && s%4 != 0 && s > 4 => (Zero [s-s%4] (ADDLconst [int32(s%4)] destptr) (MOVLstoreconst [0] destptr mem))
(Zero [8] destptr mem) => (MOVLstoreconst [makeValAndOff32(0, 4)] destptr (MOVLstoreconst [makeValAndOff32(0, 0)] destptr mem))
(Zero [12] destptr mem) => (MOVLstoreconst [makeValAndOff32(0, 8)] destptr (MOVLstoreconst [makeValAndOff32(0, 4)] destptr (MOVLstoreconst [makeValAndOff32(0, 0)] destptr mem)))
(Zero [16] destptr mem) => (MOVLstoreconst [makeValAndOff32(0, 12)] destptr (MOVLstoreconst [makeValAndOff32(0, 8)] destptr (MOVLstoreconst [makeValAndOff32(0, 4)] destptr (MOVLstoreconst [makeValAndOff32(0, 0)] destptr mem))))
(Zero [s] destptr mem) && s > 16 && s <= 4*128 && s%4 == 0 && !config.noDuffDevice => (DUFFZERO [1*(128-s/4)] destptr (MOVLconst [0]) mem)
(Zero [s] destptr mem) && (s > 4*128 || (config.noDuffDevice && s > 16)) && s%4 == 0 => (REPSTOSL destptr (MOVLconst [int32(s/4)]) (MOVLconst [0]) mem)
(Const8 [c]) => (MOVLconst [int32(c)])
(Const16 [c]) => (MOVLconst [int32(c)])
(Const32 ...) => (MOVLconst ...)
(Const(32|64)F ...) => (MOVS(S|D)const ...)
(ConstNil) => (MOVLconst [0])
(ConstBool [c]) => (MOVLconst [b2i32(c)])
(StaticCall ...) => (CALLstatic ...)
(ClosureCall ...) => (CALLclosure ...)
(InterCall ...) => (CALLinter ...)
(IsNonNil p) => (SETNE (TESTL p p))
(IsInBounds idx len) => (SETB (CMPL idx len))
(IsSliceInBounds idx len) => (SETBE (CMPL idx len))
(NilCheck ...) => (LoweredNilCheck ...)
(GetG ...) => (LoweredGetG ...)
(GetClosurePtr ...) => (LoweredGetClosurePtr ...)
(GetCallerPC ...) => (LoweredGetCallerPC ...)
(GetCallerSP ...) => (LoweredGetCallerSP ...)
(Addr {sym} base) => (LEAL {sym} base)
(LocalAddr {sym} base _) => (LEAL {sym} base)
(If (SETL cmp) yes no) => (LT cmp yes no)
(If (SETLE cmp) yes no) => (LE cmp yes no)
(If (SETG cmp) yes no) => (GT cmp yes no)
(If (SETGE cmp) yes no) => (GE cmp yes no)
(If (SETEQ cmp) yes no) => (EQ cmp yes no)
(If (SETNE cmp) yes no) => (NE cmp yes no)
(If (SETB cmp) yes no) => (ULT cmp yes no)
(If (SETBE cmp) yes no) => (ULE cmp yes no)
(If (SETA cmp) yes no) => (UGT cmp yes no)
(If (SETAE cmp) yes no) => (UGE cmp yes no)
(If (SETO cmp) yes no) => (OS cmp yes no)
(If (SETGF cmp) yes no) => (UGT cmp yes no)
(If (SETGEF cmp) yes no) => (UGE cmp yes no)
(If (SETEQF cmp) yes no) => (EQF cmp yes no)
(If (SETNEF cmp) yes no) => (NEF cmp yes no)
(If cond yes no) => (NE (TESTB cond cond) yes no)
(WB ...) => (LoweredWB ...)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 0 => (LoweredPanicBoundsA [kind] x y mem)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 1 => (LoweredPanicBoundsB [kind] x y mem)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 2 => (LoweredPanicBoundsC [kind] x y mem)
(PanicExtend [kind] hi lo y mem) && boundsABI(kind) == 0 => (LoweredPanicExtendA [kind] hi lo y mem)
(PanicExtend [kind] hi lo y mem) && boundsABI(kind) == 1 => (LoweredPanicExtendB [kind] hi lo y mem)
(PanicExtend [kind] hi lo y mem) && boundsABI(kind) == 2 => (LoweredPanicExtendC [kind] hi lo y mem)
(NE (TESTB (SETL cmp) (SETL cmp)) yes no) => (LT cmp yes no)
(NE (TESTB (SETLE cmp) (SETLE cmp)) yes no) => (LE cmp yes no)
(NE (TESTB (SETG cmp) (SETG cmp)) yes no) => (GT cmp yes no)
(NE (TESTB (SETGE cmp) (SETGE cmp)) yes no) => (GE cmp yes no)
(NE (TESTB (SETEQ cmp) (SETEQ cmp)) yes no) => (EQ cmp yes no)
(NE (TESTB (SETNE cmp) (SETNE cmp)) yes no) => (NE cmp yes no)
(NE (TESTB (SETB cmp) (SETB cmp)) yes no) => (ULT cmp yes no)
(NE (TESTB (SETBE cmp) (SETBE cmp)) yes no) => (ULE cmp yes no)
(NE (TESTB (SETA cmp) (SETA cmp)) yes no) => (UGT cmp yes no)
(NE (TESTB (SETAE cmp) (SETAE cmp)) yes no) => (UGE cmp yes no)
(NE (TESTB (SETO cmp) (SETO cmp)) yes no) => (OS cmp yes no)
(NE (TESTB (SETGF cmp) (SETGF cmp)) yes no) => (UGT cmp yes no)
(NE (TESTB (SETGEF cmp) (SETGEF cmp)) yes no) => (UGE cmp yes no)
(NE (TESTB (SETEQF cmp) (SETEQF cmp)) yes no) => (EQF cmp yes no)
(NE (TESTB (SETNEF cmp) (SETNEF cmp)) yes no) => (NEF cmp yes no)
(ADDL x (MOVLconst [c])) => (ADDLconst [c] x)
(ADDLcarry x (MOVLconst [c])) => (ADDLconstcarry [c] x)
(ADCL x (MOVLconst [c]) f) => (ADCLconst [c] x f)
(SUBL x (MOVLconst [c])) => (SUBLconst [c] x)
(SUBL (MOVLconst [c]) x) => (NEGL (SUBLconst <v.Type> [c] x))
(SUBLcarry x (MOVLconst [c])) => (SUBLconstcarry [c] x)
(SBBL x (MOVLconst [c]) f) => (SBBLconst [c] x f)
(MULL x (MOVLconst [c])) => (MULLconst [c] x)
(ANDL x (MOVLconst [c])) => (ANDLconst [c] x)
(ANDLconst [c] (ANDLconst [d] x)) => (ANDLconst [c&d] x)
(XORLconst [c] (XORLconst [d] x)) => (XORLconst [c^d] x)
(MULLconst [c] (MULLconst [d] x)) => (MULLconst [c*d] x)
(ORL x (MOVLconst [c])) => (ORLconst [c] x)
(XORL x (MOVLconst [c])) => (XORLconst [c] x)
(SHLL x (MOVLconst [c])) => (SHLLconst [c&31] x)
(SHRL x (MOVLconst [c])) => (SHRLconst [c&31] x)
(SHRW x (MOVLconst [c])) && c&31 < 16 => (SHRWconst [int16(c&31)] x)
(SHRW _ (MOVLconst [c])) && c&31 >= 16 => (MOVLconst [0])
(SHRB x (MOVLconst [c])) && c&31 < 8 => (SHRBconst [int8(c&31)] x)
(SHRB _ (MOVLconst [c])) && c&31 >= 8 => (MOVLconst [0])
(SARL x (MOVLconst [c])) => (SARLconst [c&31] x)
(SARW x (MOVLconst [c])) => (SARWconst [int16(min(int64(c&31), 15))] x)
(SARB x (MOVLconst [c])) => (SARBconst [int8(min(int64(c&31), 7))] x)
(SARL x (ANDLconst [31] y)) => (SARL x y)
(SHLL x (ANDLconst [31] y)) => (SHLL x y)
(SHRL x (ANDLconst [31] y)) => (SHRL x y)
(ADDL (SHLLconst [c] x) (SHRLconst [d] x)) && d == 32-c => (ROLLconst [c] x)
(ORL (SHLLconst [c] x) (SHRLconst [d] x)) && d == 32-c => (ROLLconst [c] x)
(XORL (SHLLconst [c] x) (SHRLconst [d] x)) && d == 32-c => (ROLLconst [c] x)
(ADDL <t> (SHLLconst [c] x) (SHRWconst [d] x)) && c < 16 && d == int16(16-c) && t.Size() == 2 => (ROLWconst [int16(c)] x)
(ORL <t> (SHLLconst [c] x) (SHRWconst [d] x)) && c < 16 && d == int16(16-c) && t.Size() == 2 => (ROLWconst [int16(c)] x)
(XORL <t> (SHLLconst [c] x) (SHRWconst [d] x)) && c < 16 && d == int16(16-c) && t.Size() == 2 => (ROLWconst [int16(c)] x)
(ADDL <t> (SHLLconst [c] x) (SHRBconst [d] x)) && c < 8 && d == int8(8-c) && t.Size() == 1 => (ROLBconst [int8(c)] x)
(ORL <t> (SHLLconst [c] x) (SHRBconst [d] x)) && c < 8 && d == int8(8-c) && t.Size() == 1 => (ROLBconst [int8(c)] x)
(XORL <t> (SHLLconst [c] x) (SHRBconst [d] x)) && c < 8 && d == int8(8-c) && t.Size() == 1 => (ROLBconst [int8(c)] x)
(ROLLconst [c] (ROLLconst [d] x)) => (ROLLconst [(c+d)&31] x)
(ROLWconst [c] (ROLWconst [d] x)) => (ROLWconst [(c+d)&15] x)
(ROLBconst [c] (ROLBconst [d] x)) => (ROLBconst [(c+d)&7] x)
(SHLLconst [0] x) => x
(SHRLconst [0] x) => x
(SARLconst [0] x) => x
(SHRWconst [0] x) => x
(SARWconst [0] x) => x
(SHRBconst [0] x) => x
(SARBconst [0] x) => x
(ROLLconst [0] x) => x
(ROLWconst [0] x) => x
(ROLBconst [0] x) => x
(CMPL x (MOVLconst [c])) => (CMPLconst [c] x)
(CMPL (MOVLconst [c]) x) => (InvertFlags (CMPLconst [c] x))
(CMPW x (MOVLconst [c])) => (CMPWconst [int16(c)] x)
(CMPW (MOVLconst [c]) x) => (InvertFlags (CMPWconst [int16(c)] x))
(CMPB x (MOVLconst [c])) => (CMPBconst [int8(c)] x)
(CMPB (MOVLconst [c]) x) => (InvertFlags (CMPBconst [int8(c)] x))
(CMP(L|W|B) x y) && x.ID > y.ID => (InvertFlags (CMP(L|W|B) y x))
(MULLconst [-9] x) => (NEGL (LEAL8 <v.Type> x x))
(MULLconst [-5] x) => (NEGL (LEAL4 <v.Type> x x))
(MULLconst [-3] x) => (NEGL (LEAL2 <v.Type> x x))
(MULLconst [-1] x) => (NEGL x)
(MULLconst [0] _) => (MOVLconst [0])
(MULLconst [1] x) => x
(MULLconst [3] x) => (LEAL2 x x)
(MULLconst [5] x) => (LEAL4 x x)
(MULLconst [7] x) => (LEAL2 x (LEAL2 <v.Type> x x))
(MULLconst [9] x) => (LEAL8 x x)
(MULLconst [11] x) => (LEAL2 x (LEAL4 <v.Type> x x))
(MULLconst [13] x) => (LEAL4 x (LEAL2 <v.Type> x x))
(MULLconst [19] x) => (LEAL2 x (LEAL8 <v.Type> x x))
(MULLconst [21] x) => (LEAL4 x (LEAL4 <v.Type> x x))
(MULLconst [25] x) => (LEAL8 x (LEAL2 <v.Type> x x))
(MULLconst [27] x) => (LEAL8 (LEAL2 <v.Type> x x) (LEAL2 <v.Type> x x))
(MULLconst [37] x) => (LEAL4 x (LEAL8 <v.Type> x x))
(MULLconst [41] x) => (LEAL8 x (LEAL4 <v.Type> x x))
(MULLconst [45] x) => (LEAL8 (LEAL4 <v.Type> x x) (LEAL4 <v.Type> x x))
(MULLconst [73] x) => (LEAL8 x (LEAL8 <v.Type> x x))
(MULLconst [81] x) => (LEAL8 (LEAL8 <v.Type> x x) (LEAL8 <v.Type> x x))
(MULLconst [c] x) && isPowerOfTwo32(c+1) && c >= 15 => (SUBL (SHLLconst <v.Type> [int32(log32(c+1))] x) x)
(MULLconst [c] x) && isPowerOfTwo32(c-1) && c >= 17 => (LEAL1 (SHLLconst <v.Type> [int32(log32(c-1))] x) x)
(MULLconst [c] x) && isPowerOfTwo32(c-2) && c >= 34 => (LEAL2 (SHLLconst <v.Type> [int32(log32(c-2))] x) x)
(MULLconst [c] x) && isPowerOfTwo32(c-4) && c >= 68 => (LEAL4 (SHLLconst <v.Type> [int32(log32(c-4))] x) x)
(MULLconst [c] x) && isPowerOfTwo32(c-8) && c >= 136 => (LEAL8 (SHLLconst <v.Type> [int32(log32(c-8))] x) x)
(MULLconst [c] x) && c%3 == 0 && isPowerOfTwo32(c/3) => (SHLLconst [int32(log32(c/3))] (LEAL2 <v.Type> x x))
(MULLconst [c] x) && c%5 == 0 && isPowerOfTwo32(c/5) => (SHLLconst [int32(log32(c/5))] (LEAL4 <v.Type> x x))
(MULLconst [c] x) && c%9 == 0 && isPowerOfTwo32(c/9) => (SHLLconst [int32(log32(c/9))] (LEAL8 <v.Type> x x))
(ADDL x (SHLLconst [3] y)) => (LEAL8 x y)
(ADDL x (SHLLconst [2] y)) => (LEAL4 x y)
(ADDL x (SHLLconst [1] y)) => (LEAL2 x y)
(ADDL x (ADDL y y)) => (LEAL2 x y)
(ADDL x (ADDL x y)) => (LEAL2 y x)
(ADDLconst [c] (ADDL x y)) => (LEAL1 [c] x y)
(ADDL (ADDLconst [c] x) y) => (LEAL1 [c] x y)
(ADDLconst [c] (LEAL [d] {s} x)) && is32Bit(int64(c)+int64(d)) => (LEAL [c+d] {s} x)
(LEAL [c] {s} (ADDLconst [d] x)) && is32Bit(int64(c)+int64(d)) => (LEAL [c+d] {s} x)
(ADDLconst [c] x:(SP)) => (LEAL [c] x)
(LEAL [c] {s} (ADDL x y)) && x.Op != OpSB && y.Op != OpSB => (LEAL1 [c] {s} x y)
(ADDL x (LEAL [c] {s} y)) && x.Op != OpSB && y.Op != OpSB => (LEAL1 [c] {s} x y)
(ADDLconst [c] (LEAL1 [d] {s} x y)) && is32Bit(int64(c)+int64(d)) => (LEAL1 [c+d] {s} x y)
(ADDLconst [c] (LEAL2 [d] {s} x y)) && is32Bit(int64(c)+int64(d)) => (LEAL2 [c+d] {s} x y)
(ADDLconst [c] (LEAL4 [d] {s} x y)) && is32Bit(int64(c)+int64(d)) => (LEAL4 [c+d] {s} x y)
(ADDLconst [c] (LEAL8 [d] {s} x y)) && is32Bit(int64(c)+int64(d)) => (LEAL8 [c+d] {s} x y)
(LEAL1 [c] {s} (ADDLconst [d] x) y) && is32Bit(int64(c)+int64(d)) && x.Op != OpSB => (LEAL1 [c+d] {s} x y)
(LEAL2 [c] {s} (ADDLconst [d] x) y) && is32Bit(int64(c)+int64(d)) && x.Op != OpSB => (LEAL2 [c+d] {s} x y)
(LEAL2 [c] {s} x (ADDLconst [d] y)) && is32Bit(int64(c)+2*int64(d)) && y.Op != OpSB => (LEAL2 [c+2*d] {s} x y)
(LEAL4 [c] {s} (ADDLconst [d] x) y) && is32Bit(int64(c)+int64(d)) && x.Op != OpSB => (LEAL4 [c+d] {s} x y)
(LEAL4 [c] {s} x (ADDLconst [d] y)) && is32Bit(int64(c)+4*int64(d)) && y.Op != OpSB => (LEAL4 [c+4*d] {s} x y)
(LEAL8 [c] {s} (ADDLconst [d] x) y) && is32Bit(int64(c)+int64(d)) && x.Op != OpSB => (LEAL8 [c+d] {s} x y)
(LEAL8 [c] {s} x (ADDLconst [d] y)) && is32Bit(int64(c)+8*int64(d)) && y.Op != OpSB => (LEAL8 [c+8*d] {s} x y)
(LEAL1 [c] {s} x (SHLLconst [1] y)) => (LEAL2 [c] {s} x y)
(LEAL1 [c] {s} x (SHLLconst [2] y)) => (LEAL4 [c] {s} x y)
(LEAL1 [c] {s} x (SHLLconst [3] y)) => (LEAL8 [c] {s} x y)
(LEAL2 [c] {s} x (SHLLconst [1] y)) => (LEAL4 [c] {s} x y)
(LEAL2 [c] {s} x (SHLLconst [2] y)) => (LEAL8 [c] {s} x y)
(LEAL4 [c] {s} x (SHLLconst [1] y)) => (LEAL8 [c] {s} x y)
(SETL (InvertFlags x)) => (SETG x)
(SETG (InvertFlags x)) => (SETL x)
(SETB (InvertFlags x)) => (SETA x)
(SETA (InvertFlags x)) => (SETB x)
(SETLE (InvertFlags x)) => (SETGE x)
(SETGE (InvertFlags x)) => (SETLE x)
(SETBE (InvertFlags x)) => (SETAE x)
(SETAE (InvertFlags x)) => (SETBE x)
(SETEQ (InvertFlags x)) => (SETEQ x)
(SETNE (InvertFlags x)) => (SETNE x)
(MOVBLSX x:(MOVBload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) => @x.Block (MOVBLSXload <v.Type> [off] {sym} ptr mem)
(MOVBLZX x:(MOVBload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) => @x.Block (MOVBload <v.Type> [off] {sym} ptr mem)
(MOVWLSX x:(MOVWload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) => @x.Block (MOVWLSXload <v.Type> [off] {sym} ptr mem)
(MOVWLZX x:(MOVWload [off] {sym} ptr mem)) && x.Uses == 1 && clobber(x) => @x.Block (MOVWload <v.Type> [off] {sym} ptr mem)
(MOVBload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _)) && sym == sym2 && off == off2 && isSamePtr(ptr, ptr2) => (MOVBLZX x)
(MOVWload [off] {sym} ptr (MOVWstore [off2] {sym2} ptr2 x _)) && sym == sym2 && off == off2 && isSamePtr(ptr, ptr2) => (MOVWLZX x)
(MOVLload [off] {sym} ptr (MOVLstore [off2] {sym2} ptr2 x _)) && sym == sym2 && off == off2 && isSamePtr(ptr, ptr2) => x
(MOVBLSXload [off] {sym} ptr (MOVBstore [off2] {sym2} ptr2 x _)) && sym == sym2 && off == off2 && isSamePtr(ptr, ptr2) => (MOVBLSX x)
(MOVWLSXload [off] {sym} ptr (MOVWstore [off2] {sym2} ptr2 x _)) && sym == sym2 && off == off2 && isSamePtr(ptr, ptr2) => (MOVWLSX x)
(MOVBLZX (ANDLconst [c] x)) => (ANDLconst [c&0xff] x)
(MOVWLZX (ANDLconst [c] x)) => (ANDLconst [c&0xffff] x)
(MOVBLSX (ANDLconst [c] x)) && c&0x80 == 0 => (ANDLconst [c&0x7f] x)
(MOVWLSX (ANDLconst [c] x)) && c&0x8000 == 0 => (ANDLconst [c&0x7fff] x)
(MOVWstore [off] {sym} ptr (MOVWL(S|Z)X x) mem) => (MOVWstore [off] {sym} ptr x mem)
(MOVBstore [off] {sym} ptr (MOVBL(S|Z)X x) mem) => (MOVBstore [off] {sym} ptr x mem)
(MOV(L|W|B|SS|SD)load [off1] {sym} (ADDLconst [off2] ptr) mem) && is32Bit(int64(off1)+int64(off2)) => (MOV(L|W|B|SS|SD)load [off1+off2] {sym} ptr mem)
(MOV(L|W|B|SS|SD)store [off1] {sym} (ADDLconst [off2] ptr) val mem) && is32Bit(int64(off1)+int64(off2)) => (MOV(L|W|B|SS|SD)store [off1+off2] {sym} ptr val mem)
((ADD|SUB|MUL|AND|OR|XOR)Lload [off1] {sym} val (ADDLconst [off2] base) mem) && is32Bit(int64(off1)+int64(off2)) => ((ADD|SUB|MUL|AND|OR|XOR)Lload [off1+off2] {sym} val base mem)
((ADD|SUB|MUL|DIV)SSload [off1] {sym} val (ADDLconst [off2] base) mem) && is32Bit(int64(off1)+int64(off2)) => ((ADD|SUB|MUL|DIV)SSload [off1+off2] {sym} val base mem)
((ADD|SUB|MUL|DIV)SDload [off1] {sym} val (ADDLconst [off2] base) mem) && is32Bit(int64(off1)+int64(off2)) => ((ADD|SUB|MUL|DIV)SDload [off1+off2] {sym} val base mem)
((ADD|SUB|AND|OR|XOR)Lmodify [off1] {sym} (ADDLconst [off2] base) val mem) && is32Bit(int64(off1)+int64(off2)) => ((ADD|SUB|AND|OR|XOR)Lmodify [off1+off2] {sym} base val mem)
((ADD|AND|OR|XOR)Lconstmodify [valoff1] {sym} (ADDLconst [off2] base) mem) && valoff1.canAdd32(off2) => ((ADD|AND|OR|XOR)Lconstmodify [valoff1.addOffset32(off2)] {sym} base mem)
(MOVLstore [off] {sym} ptr (MOVLconst [c]) mem) && validOff(int64(off)) => (MOVLstoreconst [makeValAndOff32(c, off)] {sym} ptr mem)
(MOVWstore [off] {sym} ptr (MOVLconst [c]) mem) && validOff(int64(off)) => (MOVWstoreconst [makeValAndOff32(c, off)] {sym} ptr mem)
(MOVBstore [off] {sym} ptr (MOVLconst [c]) mem) && validOff(int64(off)) => (MOVBstoreconst [makeValAndOff32(c, off)] {sym} ptr mem)
(MOV(L|W|B)storeconst [sc] {s} (ADDLconst [off] ptr) mem) && sc.canAdd32(off) => (MOV(L|W|B)storeconst [sc.addOffset32(off)] {s} ptr mem)
(MOV(L|W|B|SS|SD|BLSX|WLSX)load [off1] {sym1} (LEAL [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || !config.ctxt.Flag_shared) => (MOV(L|W|B|SS|SD|BLSX|WLSX)load [off1+off2] {mergeSym(sym1, sym2)} base mem)
(MOV(L|W|B|SS|SD)store [off1] {sym1} (LEAL [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || !config.ctxt.Flag_shared) => (MOV(L|W|B|SS|SD)store [off1+off2] {mergeSym(sym1, sym2)} base val mem)
(MOV(L|W|B)storeconst [sc] {sym1} (LEAL [off] {sym2} ptr) mem) && canMergeSym(sym1, sym2) && sc.canAdd32(off) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) => (MOV(L|W|B)storeconst [sc.addOffset32(off)] {mergeSym(sym1, sym2)} ptr mem)
((ADD|SUB|MUL|AND|OR|XOR)Lload [off1] {sym1} val (LEAL [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || !config.ctxt.Flag_shared) => ((ADD|SUB|MUL|AND|OR|XOR)Lload [off1+off2] {mergeSym(sym1, sym2)} val base mem)
((ADD|SUB|MUL|DIV)SSload [off1] {sym1} val (LEAL [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || !config.ctxt.Flag_shared) => ((ADD|SUB|MUL|DIV)SSload [off1+off2] {mergeSym(sym1, sym2)} val base mem)
((ADD|SUB|MUL|DIV)SDload [off1] {sym1} val (LEAL [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || !config.ctxt.Flag_shared) => ((ADD|SUB|MUL|DIV)SDload [off1+off2] {mergeSym(sym1, sym2)} val base mem)
((ADD|SUB|AND|OR|XOR)Lmodify [off1] {sym1} (LEAL [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || !config.ctxt.Flag_shared) => ((ADD|SUB|AND|OR|XOR)Lmodify [off1+off2] {mergeSym(sym1, sym2)} base val mem)
((ADD|AND|OR|XOR)Lconstmodify [valoff1] {sym1} (LEAL [off2] {sym2} base) mem) && valoff1.canAdd32(off2) && canMergeSym(sym1, sym2) && (base.Op != OpSB || !config.ctxt.Flag_shared) => ((ADD|AND|OR|XOR)Lconstmodify [valoff1.addOffset32(off2)] {mergeSym(sym1, sym2)} base mem)
((ADD|AND|OR|XOR|SUB|MUL)L x l:(MOVLload [off] {sym} ptr mem)) && canMergeLoadClobber(v, l, x) && clobber(l) => ((ADD|AND|OR|XOR|SUB|MUL)Lload [off] {sym} x ptr mem)
((ADD|SUB|MUL|DIV)SD x l:(MOVSDload [off] {sym} ptr mem)) && canMergeLoadClobber(v, l, x) && clobber(l) => ((ADD|SUB|MUL|DIV)SDload [off] {sym} x ptr mem)
((ADD|SUB|MUL|DIV)SS x l:(MOVSSload [off] {sym} ptr mem)) && canMergeLoadClobber(v, l, x) && clobber(l) => ((ADD|SUB|MUL|DIV)SSload [off] {sym} x ptr mem)
(MOVLstore [off] {sym} ptr y:((ADD|AND|OR|XOR)Lload [off] {sym} x ptr mem) mem) && y.Uses == 1 && clobber(y) => ((ADD|AND|OR|XOR)Lmodify [off] {sym} ptr x mem)
(MOVLstore [off] {sym} ptr y:((ADD|SUB|AND|OR|XOR)L l:(MOVLload [off] {sym} ptr mem) x) mem) && y.Uses == 1 && l.Uses == 1 && clobber(y, l) => ((ADD|SUB|AND|OR|XOR)Lmodify [off] {sym} ptr x mem)
(MOVLstore [off] {sym} ptr y:((ADD|AND|OR|XOR)Lconst [c] l:(MOVLload [off] {sym} ptr mem)) mem) && y.Uses == 1 && l.Uses == 1 && clobber(y, l) && validValAndOff(int64(c), int64(off)) => ((ADD|AND|OR|XOR)Lconstmodify [makeValAndOff32(c, off)] {sym} ptr mem)
(LEAL [off1] {sym1} (LEAL [off2] {sym2} x)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (LEAL [off1+off2] {mergeSym(sym1, sym2)} x)
(LEAL1 [off1] {sym1} (LEAL [off2] {sym2} x) y) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && x.Op != OpSB => (LEAL1 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL [off1] {sym1} (LEAL1 [off2] {sym2} x y)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (LEAL1 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL2 [off1] {sym1} (LEAL [off2] {sym2} x) y) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && x.Op != OpSB => (LEAL2 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL4 [off1] {sym1} (LEAL [off2] {sym2} x) y) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && x.Op != OpSB => (LEAL4 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL8 [off1] {sym1} (LEAL [off2] {sym2} x) y) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && x.Op != OpSB => (LEAL8 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL [off1] {sym1} (LEAL2 [off2] {sym2} x y)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (LEAL2 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL [off1] {sym1} (LEAL4 [off2] {sym2} x y)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (LEAL4 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL [off1] {sym1} (LEAL8 [off2] {sym2} x y)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (LEAL8 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL1 [off1] {sym1} x (LEAL1 [off2] {sym2} y y)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (LEAL2 [off1+off2] {mergeSym(sym1, sym2)} x y)
(LEAL1 [off1] {sym1} x (LEAL1 [off2] {sym2} x y)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (LEAL2 [off1+off2] {mergeSym(sym1, sym2)} y x)
(LEAL2 [off1] {sym} x (LEAL1 [off2] {nil} y y)) && is32Bit(int64(off1)+2*int64(off2)) => (LEAL4 [off1+2*off2] {sym} x y)
(LEAL4 [off1] {sym} x (LEAL1 [off2] {nil} y y)) && is32Bit(int64(off1)+4*int64(off2)) => (LEAL8 [off1+4*off2] {sym} x y)
(LT (InvertFlags cmp) yes no) => (GT cmp yes no)
(GT (InvertFlags cmp) yes no) => (LT cmp yes no)
(LE (InvertFlags cmp) yes no) => (GE cmp yes no)
(GE (InvertFlags cmp) yes no) => (LE cmp yes no)
(ULT (InvertFlags cmp) yes no) => (UGT cmp yes no)
(UGT (InvertFlags cmp) yes no) => (ULT cmp yes no)
(ULE (InvertFlags cmp) yes no) => (UGE cmp yes no)
(UGE (InvertFlags cmp) yes no) => (ULE cmp yes no)
(EQ (InvertFlags cmp) yes no) => (EQ cmp yes no)
(NE (InvertFlags cmp) yes no) => (NE cmp yes no)
(CMPLconst [y] (MOVLconst [x])) && x == y => (FlagEQ)
(CMPLconst [y] (MOVLconst [x])) && x < y && uint32(x) < uint32(y) => (FlagLT_ULT)
(CMPLconst [y] (MOVLconst [x])) && x < y && uint32(x) > uint32(y) => (FlagLT_UGT)
(CMPLconst [y] (MOVLconst [x])) && x > y && uint32(x) < uint32(y) => (FlagGT_ULT)
(CMPLconst [y] (MOVLconst [x])) && x > y && uint32(x) > uint32(y) => (FlagGT_UGT)
(CMPWconst [y] (MOVLconst [x])) && int16(x) == y => (FlagEQ)
(CMPWconst [y] (MOVLconst [x])) && int16(x) < y && uint16(x) < uint16(y) => (FlagLT_ULT)
(CMPWconst [y] (MOVLconst [x])) && int16(x) < y && uint16(x) > uint16(y) => (FlagLT_UGT)
(CMPWconst [y] (MOVLconst [x])) && int16(x) > y && uint16(x) < uint16(y) => (FlagGT_ULT)
(CMPWconst [y] (MOVLconst [x])) && int16(x) > y && uint16(x) > uint16(y) => (FlagGT_UGT)
(CMPBconst [y] (MOVLconst [x])) && int8(x) == y => (FlagEQ)
(CMPBconst [y] (MOVLconst [x])) && int8(x) < y && uint8(x) < uint8(y) => (FlagLT_ULT)
(CMPBconst [y] (MOVLconst [x])) && int8(x) < y && uint8(x) > uint8(y) => (FlagLT_UGT)
(CMPBconst [y] (MOVLconst [x])) && int8(x) > y && uint8(x) < uint8(y) => (FlagGT_ULT)
(CMPBconst [y] (MOVLconst [x])) && int8(x) > y && uint8(x) > uint8(y) => (FlagGT_UGT)
(CMPLconst [n] (SHRLconst [c] _)) && 0 <= n && 0 < c && c <= 32 && (1<<uint64(32-c)) <= uint64(n) => (FlagLT_ULT)
(CMPLconst [n] (ANDLconst [m] _)) && 0 <= m && m < n => (FlagLT_ULT)
(CMPWconst [n] (ANDLconst [m] _)) && 0 <= int16(m) && int16(m) < n => (FlagLT_ULT)
(CMPBconst [n] (ANDLconst [m] _)) && 0 <= int8(m) && int8(m) < n => (FlagLT_ULT)
(SBBLcarrymask (FlagEQ)) => (MOVLconst [0])
(SBBLcarrymask (FlagLT_ULT)) => (MOVLconst [-1])
(SBBLcarrymask (FlagLT_UGT)) => (MOVLconst [0])
(SBBLcarrymask (FlagGT_ULT)) => (MOVLconst [-1])
(SBBLcarrymask (FlagGT_UGT)) => (MOVLconst [0])
(EQ (FlagEQ) yes no) => (First yes no)
(EQ (FlagLT_ULT) yes no) => (First no yes)
(EQ (FlagLT_UGT) yes no) => (First no yes)
(EQ (FlagGT_ULT) yes no) => (First no yes)
(EQ (FlagGT_UGT) yes no) => (First no yes)
(NE (FlagEQ) yes no) => (First no yes)
(NE (FlagLT_ULT) yes no) => (First yes no)
(NE (FlagLT_UGT) yes no) => (First yes no)
(NE (FlagGT_ULT) yes no) => (First yes no)
(NE (FlagGT_UGT) yes no) => (First yes no)
(LT (FlagEQ) yes no) => (First no yes)
(LT (FlagLT_ULT) yes no) => (First yes no)
(LT (FlagLT_UGT) yes no) => (First yes no)
(LT (FlagGT_ULT) yes no) => (First no yes)
(LT (FlagGT_UGT) yes no) => (First no yes)
(LE (FlagEQ) yes no) => (First yes no)
(LE (FlagLT_ULT) yes no) => (First yes no)
(LE (FlagLT_UGT) yes no) => (First yes no)
(LE (FlagGT_ULT) yes no) => (First no yes)
(LE (FlagGT_UGT) yes no) => (First no yes)
(GT (FlagEQ) yes no) => (First no yes)
(GT (FlagLT_ULT) yes no) => (First no yes)
(GT (FlagLT_UGT) yes no) => (First no yes)
(GT (FlagGT_ULT) yes no) => (First yes no)
(GT (FlagGT_UGT) yes no) => (First yes no)
(GE (FlagEQ) yes no) => (First yes no)
(GE (FlagLT_ULT) yes no) => (First no yes)
(GE (FlagLT_UGT) yes no) => (First no yes)
(GE (FlagGT_ULT) yes no) => (First yes no)
(GE (FlagGT_UGT) yes no) => (First yes no)
(ULT (FlagEQ) yes no) => (First no yes)
(ULT (FlagLT_ULT) yes no) => (First yes no)
(ULT (FlagLT_UGT) yes no) => (First no yes)
(ULT (FlagGT_ULT) yes no) => (First yes no)
(ULT (FlagGT_UGT) yes no) => (First no yes)
(ULE (FlagEQ) yes no) => (First yes no)
(ULE (FlagLT_ULT) yes no) => (First yes no)
(ULE (FlagLT_UGT) yes no) => (First no yes)
(ULE (FlagGT_ULT) yes no) => (First yes no)
(ULE (FlagGT_UGT) yes no) => (First no yes)
(UGT (FlagEQ) yes no) => (First no yes)
(UGT (FlagLT_ULT) yes no) => (First no yes)
(UGT (FlagLT_UGT) yes no) => (First yes no)
(UGT (FlagGT_ULT) yes no) => (First no yes)
(UGT (FlagGT_UGT) yes no) => (First yes no)
(UGE (FlagEQ) yes no) => (First yes no)
(UGE (FlagLT_ULT) yes no) => (First no yes)
(UGE (FlagLT_UGT) yes no) => (First yes no)
(UGE (FlagGT_ULT) yes no) => (First no yes)
(UGE (FlagGT_UGT) yes no) => (First yes no)
(SETEQ (FlagEQ)) => (MOVLconst [1])
(SETEQ (FlagLT_ULT)) => (MOVLconst [0])
(SETEQ (FlagLT_UGT)) => (MOVLconst [0])
(SETEQ (FlagGT_ULT)) => (MOVLconst [0])
(SETEQ (FlagGT_UGT)) => (MOVLconst [0])
(SETNE (FlagEQ)) => (MOVLconst [0])
(SETNE (FlagLT_ULT)) => (MOVLconst [1])
(SETNE (FlagLT_UGT)) => (MOVLconst [1])
(SETNE (FlagGT_ULT)) => (MOVLconst [1])
(SETNE (FlagGT_UGT)) => (MOVLconst [1])
(SETL (FlagEQ)) => (MOVLconst [0])
(SETL (FlagLT_ULT)) => (MOVLconst [1])
(SETL (FlagLT_UGT)) => (MOVLconst [1])
(SETL (FlagGT_ULT)) => (MOVLconst [0])
(SETL (FlagGT_UGT)) => (MOVLconst [0])
(SETLE (FlagEQ)) => (MOVLconst [1])
(SETLE (FlagLT_ULT)) => (MOVLconst [1])
(SETLE (FlagLT_UGT)) => (MOVLconst [1])
(SETLE (FlagGT_ULT)) => (MOVLconst [0])
(SETLE (FlagGT_UGT)) => (MOVLconst [0])
(SETG (FlagEQ)) => (MOVLconst [0])
(SETG (FlagLT_ULT)) => (MOVLconst [0])
(SETG (FlagLT_UGT)) => (MOVLconst [0])
(SETG (FlagGT_ULT)) => (MOVLconst [1])
(SETG (FlagGT_UGT)) => (MOVLconst [1])
(SETGE (FlagEQ)) => (MOVLconst [1])
(SETGE (FlagLT_ULT)) => (MOVLconst [0])
(SETGE (FlagLT_UGT)) => (MOVLconst [0])
(SETGE (FlagGT_ULT)) => (MOVLconst [1])
(SETGE (FlagGT_UGT)) => (MOVLconst [1])
(SETB (FlagEQ)) => (MOVLconst [0])
(SETB (FlagLT_ULT)) => (MOVLconst [1])
(SETB (FlagLT_UGT)) => (MOVLconst [0])
(SETB (FlagGT_ULT)) => (MOVLconst [1])
(SETB (FlagGT_UGT)) => (MOVLconst [0])
(SETBE (FlagEQ)) => (MOVLconst [1])
(SETBE (FlagLT_ULT)) => (MOVLconst [1])
(SETBE (FlagLT_UGT)) => (MOVLconst [0])
(SETBE (FlagGT_ULT)) => (MOVLconst [1])
(SETBE (FlagGT_UGT)) => (MOVLconst [0])
(SETA (FlagEQ)) => (MOVLconst [0])
(SETA (FlagLT_ULT)) => (MOVLconst [0])
(SETA (FlagLT_UGT)) => (MOVLconst [1])
(SETA (FlagGT_ULT)) => (MOVLconst [0])
(SETA (FlagGT_UGT)) => (MOVLconst [1])
(SETAE (FlagEQ)) => (MOVLconst [1])
(SETAE (FlagLT_ULT)) => (MOVLconst [0])
(SETAE (FlagLT_UGT)) => (MOVLconst [1])
(SETAE (FlagGT_ULT)) => (MOVLconst [0])
(SETAE (FlagGT_UGT)) => (MOVLconst [1])
(ADDLconst [c] x) && c == 0 => x
(SUBLconst [c] x) && c == 0 => x
(ANDLconst [c] _) && c == 0 => (MOVLconst [0])
(ANDLconst [c] x) && c == -1 => x
(ORLconst [c] x) && c == 0 => x
(ORLconst [c] _) && c == -1 => (MOVLconst [-1])
(XORLconst [c] x) && c == 0 => x
(SUBLconst [c] x) => (ADDLconst [-c] x)
(ADDLconst [c] (MOVLconst [d])) => (MOVLconst [c+d])
(ADDLconst [c] (ADDLconst [d] x)) => (ADDLconst [c+d] x)
(SARLconst [c] (MOVLconst [d])) => (MOVLconst [d>>uint64(c)])
(SARWconst [c] (MOVLconst [d])) => (MOVLconst [d>>uint64(c)])
(SARBconst [c] (MOVLconst [d])) => (MOVLconst [d>>uint64(c)])
(NEGL (MOVLconst [c])) => (MOVLconst [-c])
(MULLconst [c] (MOVLconst [d])) => (MOVLconst [c*d])
(ANDLconst [c] (MOVLconst [d])) => (MOVLconst [c&d])
(ORLconst [c] (MOVLconst [d])) => (MOVLconst [c|d])
(XORLconst [c] (MOVLconst [d])) => (MOVLconst [c^d])
(NOTL (MOVLconst [c])) => (MOVLconst [^c])
(ADDL x (NEGL y)) => (SUBL x y)
(SUBL x x) => (MOVLconst [0])
(ANDL x x) => x
(ORL x x) => x
(XORL x x) => (MOVLconst [0])
(CMP(L|W|B)const [0] l:(ANDL x y)) && l.Uses == 1 => (TEST(L|W|B) x y)
(CMPLconst [0] l:(ANDLconst [c] x)) && l.Uses == 1 => (TESTLconst [c] x)
(CMPWconst [0] l:(ANDLconst [c] x)) && l.Uses == 1 => (TESTWconst [int16(c)] x)
(CMPBconst [0] l:(ANDLconst [c] x)) && l.Uses == 1 => (TESTBconst [int8(c)] x)
(CMP(L|W|B)const [0] x) => (TEST(L|W|B) x x)
(LEAL1 [0] {nil} x y) => (ADDL x y)
(ORL x0:(MOVBload [i0] {s} p mem) s0:(SHLLconst [8] x1:(MOVBload [i1] {s} p mem))) && i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, s0) => @mergePoint(b,x0,x1) (MOVWload [i0] {s} p mem)
(ORL x0:(MOVBload [i] {s} p0 mem) s0:(SHLLconst [8] x1:(MOVBload [i] {s} p1 mem))) && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && sequentialAddresses(p0, p1, 1) && mergePoint(b, x0, x1) != nil && clobber(x0, x1, s0) => @mergePoint(b,x0,x1) (MOVWload [i] {s} p0 mem)
(ORL o0:(ORL x0:(MOVWload [i0] {s} p mem) s0:(SHLLconst [16] x1:(MOVBload [i2] {s} p mem))) s1:(SHLLconst [24] x2:(MOVBload [i3] {s} p mem))) && i2 == i0+2 && i3 == i0+3 && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && o0.Uses == 1 && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0) => @mergePoint(b,x0,x1,x2) (MOVLload [i0] {s} p mem)
(ORL o0:(ORL x0:(MOVWload [i] {s} p0 mem) s0:(SHLLconst [16] x1:(MOVBload [i] {s} p1 mem))) s1:(SHLLconst [24] x2:(MOVBload [i] {s} p2 mem))) && x0.Uses == 1 && x1.Uses == 1 && x2.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && o0.Uses == 1 && sequentialAddresses(p0, p1, 2) && sequentialAddresses(p1, p2, 1) && mergePoint(b, x0, x1, x2) != nil && clobber(x0, x1, x2, s0, s1, o0) => @mergePoint(b,x0,x1,x2) (MOVLload [i] {s} p0 mem)
(MOVBstoreconst [c] {s} p x:(MOVBstoreconst [a] {s} p mem)) && x.Uses == 1 && a.Off()+1 == c.Off() && clobber(x) => (MOVWstoreconst [makeValAndOff32(int32(a.Val()&0xff|c.Val()<<8), a.Off32())] {s} p mem)
(MOVBstoreconst [a] {s} p x:(MOVBstoreconst [c] {s} p mem)) && x.Uses == 1 && a.Off()+1 == c.Off() && clobber(x) => (MOVWstoreconst [makeValAndOff32(int32(a.Val()&0xff|c.Val()<<8), a.Off32())] {s} p mem)
(MOVBstoreconst [c] {s} p1 x:(MOVBstoreconst [a] {s} p0 mem)) && x.Uses == 1 && a.Off() == c.Off() && sequentialAddresses(p0, p1, 1) && clobber(x) => (MOVWstoreconst [makeValAndOff32(int32(a.Val()&0xff|c.Val()<<8), a.Off32())] {s} p0 mem)
(MOVBstoreconst [a] {s} p0 x:(MOVBstoreconst [c] {s} p1 mem)) && x.Uses == 1 && a.Off() == c.Off() && sequentialAddresses(p0, p1, 1) && clobber(x) => (MOVWstoreconst [makeValAndOff32(int32(a.Val()&0xff|c.Val()<<8), a.Off32())] {s} p0 mem)
(MOVWstoreconst [c] {s} p x:(MOVWstoreconst [a] {s} p mem)) && x.Uses == 1 && a.Off()+2 == c.Off() && clobber(x) => (MOVLstoreconst [makeValAndOff32(int32(a.Val()&0xffff|c.Val()<<16), a.Off32())] {s} p mem)
(MOVWstoreconst [a] {s} p x:(MOVWstoreconst [c] {s} p mem)) && x.Uses == 1 && ValAndOff(a).Off()+2 == ValAndOff(c).Off() && clobber(x) => (MOVLstoreconst [makeValAndOff32(int32(a.Val()&0xffff|c.Val()<<16), a.Off32())] {s} p mem)
(MOVWstoreconst [c] {s} p1 x:(MOVWstoreconst [a] {s} p0 mem)) && x.Uses == 1 && a.Off() == c.Off() && sequentialAddresses(p0, p1, 2) && clobber(x) => (MOVLstoreconst [makeValAndOff32(int32(a.Val()&0xffff|c.Val()<<16), a.Off32())] {s} p0 mem)
(MOVWstoreconst [a] {s} p0 x:(MOVWstoreconst [c] {s} p1 mem)) && x.Uses == 1 && a.Off() == c.Off() && sequentialAddresses(p0, p1, 2) && clobber(x) => (MOVLstoreconst [makeValAndOff32(int32(a.Val()&0xffff|c.Val()<<16), a.Off32())] {s} p0 mem)
(MOVBstore [i] {s} p (SHR(W|L)const [8] w) x:(MOVBstore [i-1] {s} p w mem)) && x.Uses == 1 && clobber(x) => (MOVWstore [i-1] {s} p w mem)
(MOVBstore [i] {s} p w x:(MOVBstore [i+1] {s} p (SHR(W|L)const [8] w) mem)) && x.Uses == 1 && clobber(x) => (MOVWstore [i] {s} p w mem)
(MOVBstore [i] {s} p (SHRLconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SHRLconst [j-8] w) mem)) && x.Uses == 1 && clobber(x) => (MOVWstore [i-1] {s} p w0 mem)
(MOVBstore [i] {s} p1 (SHR(W|L)const [8] w) x:(MOVBstore [i] {s} p0 w mem)) && x.Uses == 1 && sequentialAddresses(p0, p1, 1) && clobber(x) => (MOVWstore [i] {s} p0 w mem)
(MOVBstore [i] {s} p0 w x:(MOVBstore [i] {s} p1 (SHR(W|L)const [8] w) mem)) && x.Uses == 1 && sequentialAddresses(p0, p1, 1) && clobber(x) => (MOVWstore [i] {s} p0 w mem)
(MOVBstore [i] {s} p1 (SHRLconst [j] w) x:(MOVBstore [i] {s} p0 w0:(SHRLconst [j-8] w) mem)) && x.Uses == 1 && sequentialAddresses(p0, p1, 1) && clobber(x) => (MOVWstore [i] {s} p0 w0 mem)
(MOVWstore [i] {s} p (SHRLconst [16] w) x:(MOVWstore [i-2] {s} p w mem)) && x.Uses == 1 && clobber(x) => (MOVLstore [i-2] {s} p w mem)
(MOVWstore [i] {s} p (SHRLconst [j] w) x:(MOVWstore [i-2] {s} p w0:(SHRLconst [j-16] w) mem)) && x.Uses == 1 && clobber(x) => (MOVLstore [i-2] {s} p w0 mem)
(MOVWstore [i] {s} p1 (SHRLconst [16] w) x:(MOVWstore [i] {s} p0 w mem)) && x.Uses == 1 && sequentialAddresses(p0, p1, 2) && clobber(x) => (MOVLstore [i] {s} p0 w mem)
(MOVWstore [i] {s} p1 (SHRLconst [j] w) x:(MOVWstore [i] {s} p0 w0:(SHRLconst [j-16] w) mem)) && x.Uses == 1 && sequentialAddresses(p0, p1, 2) && clobber(x) => (MOVLstore [i] {s} p0 w0 mem)
(MOVSSconst [c]) && config.ctxt.Flag_shared => (MOVSSconst2 (MOVSSconst1 [c]))
(MOVSDconst [c]) && config.ctxt.Flag_shared => (MOVSDconst2 (MOVSDconst1 [c]))
(CMP(L|W|B) l:(MOV(L|W|B)load [off] {sym} ptr mem) x) && canMergeLoad(v, l) && clobber(l) => (CMP(L|W|B)load [off] {sym} ptr x mem)
(CMP(L|W|B) x l:(MOV(L|W|B)load [off] {sym} ptr mem)) && canMergeLoad(v, l) && clobber(l) => (InvertFlags (CMP(L|W|B)load [off] {sym} ptr x mem))
(CMP(L|W|B)const [c] l:(MOV(L|W|B)load [off] {sym} ptr mem)) && l.Uses == 1 && validValAndOff(int64(c), int64(off)) && clobber(l) => @l.Block (CMP(L|W|B)constload [makeValAndOff32(int32(c), int32(off))] {sym} ptr mem)
(CMPLload [off] {sym} ptr (MOVLconst [c]) mem) && validValAndOff(int64(c), int64(off)) => (CMPLconstload [makeValAndOff32(c, off)] {sym} ptr mem)
(CMPWload [off] {sym} ptr (MOVLconst [c]) mem) && validValAndOff(int64(int16(c)), int64(off)) => (CMPWconstload [makeValAndOff32(int32(int16(c)), off)] {sym} ptr mem)
(CMPBload [off] {sym} ptr (MOVLconst [c]) mem) && validValAndOff(int64(int8(c)), int64(off)) => (CMPBconstload [makeValAndOff32(int32(int8(c)), off)] {sym} ptr mem)
(MOVBload [off] {sym} (SB) _) && symIsRO(sym) => (MOVLconst [int32(read8(sym, int64(off)))])
(MOVWload [off] {sym} (SB) _) && symIsRO(sym) => (MOVLconst [int32(read16(sym, int64(off), config.ctxt.Arch.ByteOrder))])
(MOVLload [off] {sym} (SB) _) && symIsRO(sym) => (MOVLconst [int32(read32(sym, int64(off), config.ctxt.Arch.ByteOrder))])
