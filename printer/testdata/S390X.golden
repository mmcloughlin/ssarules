(Add(64|Ptr) ...) => (ADD ...)
(Add(32|16|8) ...) => (ADDW ...)
(Add32F x y) => (Select0 (FADDS x y))
(Add64F x y) => (Select0 (FADD x y))
(Sub(64|Ptr) ...) => (SUB ...)
(Sub(32|16|8) ...) => (SUBW ...)
(Sub32F x y) => (Select0 (FSUBS x y))
(Sub64F x y) => (Select0 (FSUB x y))
(Mul64 ...) => (MULLD ...)
(Mul(32|16|8) ...) => (MULLW ...)
(Mul32F ...) => (FMULS ...)
(Mul64F ...) => (FMUL ...)
(Mul64uhilo ...) => (MLGR ...)
(Div32F ...) => (FDIVS ...)
(Div64F ...) => (FDIV ...)
(Div64 x y) => (DIVD x y)
(Div64u ...) => (DIVDU ...)
(Div32 x y) => (DIVW (MOVWreg x) y)
(Div32u x y) => (DIVWU (MOVWZreg x) y)
(Div16 x y) => (DIVW (MOVHreg x) (MOVHreg y))
(Div16u x y) => (DIVWU (MOVHZreg x) (MOVHZreg y))
(Div8 x y) => (DIVW (MOVBreg x) (MOVBreg y))
(Div8u x y) => (DIVWU (MOVBZreg x) (MOVBZreg y))
(Hmul(64|64u) ...) => (MULH(D|DU) ...)
(Hmul32 x y) => (SRDconst [32] (MULLD (MOVWreg x) (MOVWreg y)))
(Hmul32u x y) => (SRDconst [32] (MULLD (MOVWZreg x) (MOVWZreg y)))
(Mod64 x y) => (MODD x y)
(Mod64u ...) => (MODDU ...)
(Mod32 x y) => (MODW (MOVWreg x) y)
(Mod32u x y) => (MODWU (MOVWZreg x) y)
(Mod16 x y) => (MODW (MOVHreg x) (MOVHreg y))
(Mod16u x y) => (MODWU (MOVHZreg x) (MOVHZreg y))
(Mod8 x y) => (MODW (MOVBreg x) (MOVBreg y))
(Mod8u x y) => (MODWU (MOVBZreg x) (MOVBZreg y))
(Avg64u <t> x y) => (ADD (SRDconst <t> [1] (SUB <t> x y)) y)
(And64 ...) => (AND ...)
(And(32|16|8) ...) => (ANDW ...)
(Or64 ...) => (OR ...)
(Or(32|16|8) ...) => (ORW ...)
(Xor64 ...) => (XOR ...)
(Xor(32|16|8) ...) => (XORW ...)
(Neg64 ...) => (NEG ...)
(Neg(32|16|8) ...) => (NEGW ...)
(Neg32F ...) => (FNEGS ...)
(Neg64F ...) => (FNEG ...)
(Com64 ...) => (NOT ...)
(Com(32|16|8) ...) => (NOTW ...)
(NOT x) => (XOR (MOVDconst [-1]) x)
(NOTW x) => (XORWconst [-1] x)
(AndB ...) => (ANDW ...)
(OrB ...) => (ORW ...)
(Not x) => (XORWconst [1] x)
(OffPtr [off] ptr:(SP)) => (MOVDaddr [int32(off)] ptr)
(OffPtr [off] ptr) && is32Bit(off) => (ADDconst [int32(off)] ptr)
(OffPtr [off] ptr) => (ADD (MOVDconst [off]) ptr)
(Ctz64NonZero ...) => (Ctz64 ...)
(Ctz32NonZero ...) => (Ctz32 ...)
(Ctz64 <t> x) => (SUB (MOVDconst [64]) (FLOGR (AND <t> (SUBconst <t> [1] x) (NOT <t> x))))
(Ctz32 <t> x) => (SUB (MOVDconst [64]) (FLOGR (MOVWZreg (ANDW <t> (SUBWconst <t> [1] x) (NOTW <t> x)))))
(BitLen64 x) => (SUB (MOVDconst [64]) (FLOGR x))
(PopCount8 x) => (POPCNT (MOVBZreg x))
(PopCount16 x) => (MOVBZreg (SumBytes2 (POPCNT <typ.UInt16> x)))
(PopCount32 x) => (MOVBZreg (SumBytes4 (POPCNT <typ.UInt32> x)))
(PopCount64 x) => (MOVBZreg (SumBytes8 (POPCNT <typ.UInt64> x)))
(SumBytes2 x) => (ADDW (SRWconst <typ.UInt8> [8] x) x)
(SumBytes4 x) => (SumBytes2 (ADDW <typ.UInt16> (SRWconst <typ.UInt16> [16] x) x))
(SumBytes8 x) => (SumBytes4 (ADDW <typ.UInt32> (SRDconst <typ.UInt32> [32] x) x))
(Bswap64 ...) => (MOVDBR ...)
(Bswap32 ...) => (MOVWBR ...)
(Select0 (Add64carry x y c)) => (Select0 <typ.UInt64> (ADDE x y (Select1 <types.TypeFlags> (ADDCconst [-1] c))))
(Select1 (Add64carry x y c)) => (Select0 <typ.UInt64> (ADDE (MOVDconst [0]) (MOVDconst [0]) (Select1 <types.TypeFlags> (ADDE x y (Select1 <types.TypeFlags> (ADDCconst [-1] c))))))
(Select0 (Sub64borrow x y c)) => (Select0 <typ.UInt64> (SUBE x y (Select1 <types.TypeFlags> (SUBC (MOVDconst [0]) c))))
(Select1 (Sub64borrow x y c)) => (NEG (Select0 <typ.UInt64> (SUBE (MOVDconst [0]) (MOVDconst [0]) (Select1 <types.TypeFlags> (SUBE x y (Select1 <types.TypeFlags> (SUBC (MOVDconst [0]) c)))))))
(Sqrt ...) => (FSQRT ...)
(Floor x) => (FIDBR [7] x)
(Ceil x) => (FIDBR [6] x)
(Trunc x) => (FIDBR [5] x)
(RoundToEven x) => (FIDBR [4] x)
(Round x) => (FIDBR [1] x)
(FMA x y z) => (FMADD z x y)
(AtomicLoad(8|32|Acq32|64|Ptr) ptr mem) => (MOV(BZ|WZ|WZ|D|D)atomicload ptr mem)
(AtomicStore(8|32|64|PtrNoWB) ptr val mem) => (SYNC (MOV(B|W|D|D)atomicstore ptr val mem))
(AtomicStoreRel32 ptr val mem) => (MOVWatomicstore ptr val mem)
(AtomicAdd32 ptr val mem) => (AddTupleFirst32 val (LAA ptr val mem))
(AtomicAdd64 ptr val mem) => (AddTupleFirst64 val (LAAG ptr val mem))
(Select0 <t> (AddTupleFirst32 val tuple)) => (ADDW val (Select0 <t> tuple))
(Select1 (AddTupleFirst32 _ tuple)) => (Select1 tuple)
(Select0 <t> (AddTupleFirst64 val tuple)) => (ADD val (Select0 <t> tuple))
(Select1 (AddTupleFirst64 _ tuple)) => (Select1 tuple)
(AtomicExchange32 ptr val mem) => (LoweredAtomicExchange32 ptr val mem)
(AtomicExchange64 ptr val mem) => (LoweredAtomicExchange64 ptr val mem)
(AtomicCompareAndSwap32 ptr old new_ mem) => (LoweredAtomicCas32 ptr old new_ mem)
(AtomicCompareAndSwap64 ptr old new_ mem) => (LoweredAtomicCas64 ptr old new_ mem)
(AtomicAnd8 ptr val mem) => (LANfloor ptr (RLL <typ.UInt32> (ORWconst <typ.UInt32> [-1<<8] val) (RXSBG <typ.UInt32> {s390x.NewRotateParams(59, 60, 3)} (MOVDconst [3<<3]) ptr)) mem)
(AtomicOr8 ptr val mem) => (LAOfloor ptr (SLW <typ.UInt32> (MOVBZreg <typ.UInt32> val) (RXSBG <typ.UInt32> {s390x.NewRotateParams(59, 60, 3)} (MOVDconst [3<<3]) ptr)) mem)
(AtomicAnd32 ...) => (LAN ...)
(AtomicOr32 ...) => (LAO ...)
(SignExt8to(16|32|64) ...) => (MOVBreg ...)
(SignExt16to(32|64) ...) => (MOVHreg ...)
(SignExt32to64 ...) => (MOVWreg ...)
(ZeroExt8to(16|32|64) ...) => (MOVBZreg ...)
(ZeroExt16to(32|64) ...) => (MOVHZreg ...)
(ZeroExt32to64 ...) => (MOVWZreg ...)
(Slicemask <t> x) => (SRADconst [63] (NEG <t> x))
(Trunc(16|32|64)to8 ...) => (Copy ...)
(Trunc(32|64)to16 ...) => (Copy ...)
(Trunc64to32 ...) => (Copy ...)
(Cvt32to32F ...) => (CEFBRA ...)
(Cvt32to64F ...) => (CDFBRA ...)
(Cvt64to32F ...) => (CEGBRA ...)
(Cvt64to64F ...) => (CDGBRA ...)
(Cvt32Fto32 ...) => (CFEBRA ...)
(Cvt32Fto64 ...) => (CGEBRA ...)
(Cvt64Fto32 ...) => (CFDBRA ...)
(Cvt64Fto64 ...) => (CGDBRA ...)
(Cvt32Uto32F ...) => (CELFBR ...)
(Cvt32Uto64F ...) => (CDLFBR ...)
(Cvt64Uto32F ...) => (CELGBR ...)
(Cvt64Uto64F ...) => (CDLGBR ...)
(Cvt32Fto32U ...) => (CLFEBR ...)
(Cvt32Fto64U ...) => (CLGEBR ...)
(Cvt64Fto32U ...) => (CLFDBR ...)
(Cvt64Fto64U ...) => (CLGDBR ...)
(Cvt32Fto64F ...) => (LDEBR ...)
(Cvt64Fto32F ...) => (LEDBR ...)
(CvtBoolToUint8 ...) => (Copy ...)
(Round(32|64)F ...) => (LoweredRound(32|64)F ...)
(Lsh64x(64|32|16|8) x y) && shiftIsBounded(v) => (SLD x y)
(Lsh32x(64|32|16|8) x y) && shiftIsBounded(v) => (SLW x y)
(Lsh16x(64|32|16|8) x y) && shiftIsBounded(v) => (SLW x y)
(Lsh8x(64|32|16|8) x y) && shiftIsBounded(v) => (SLW x y)
(Rsh64Ux(64|32|16|8) x y) && shiftIsBounded(v) => (SRD x y)
(Rsh32Ux(64|32|16|8) x y) && shiftIsBounded(v) => (SRW x y)
(Rsh16Ux(64|32|16|8) x y) && shiftIsBounded(v) => (SRW (MOVHZreg x) y)
(Rsh8Ux(64|32|16|8) x y) && shiftIsBounded(v) => (SRW (MOVBZreg x) y)
(Rsh64x(64|32|16|8) x y) && shiftIsBounded(v) => (SRAD x y)
(Rsh32x(64|32|16|8) x y) && shiftIsBounded(v) => (SRAW x y)
(Rsh16x(64|32|16|8) x y) && shiftIsBounded(v) => (SRAW (MOVHreg x) y)
(Rsh8x(64|32|16|8) x y) && shiftIsBounded(v) => (SRAW (MOVBreg x) y)
(Lsh(64|32|16|8)x64 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SL(D|W|W|W) <t> x y) (MOVDconst [0]) (CMPUconst [64] y))
(Lsh(64|32|16|8)x32 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SL(D|W|W|W) <t> x y) (MOVDconst [0]) (CMPWUconst [64] y))
(Lsh(64|32|16|8)x16 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SL(D|W|W|W) <t> x y) (MOVDconst [0]) (CMPWUconst [64] (MOVHZreg y)))
(Lsh(64|32|16|8)x8 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SL(D|W|W|W) <t> x y) (MOVDconst [0]) (CMPWUconst [64] (MOVBZreg y)))
(Rsh(64|32)Ux64 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SR(D|W) <t> x y) (MOVDconst [0]) (CMPUconst [64] y))
(Rsh(64|32)Ux32 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SR(D|W) <t> x y) (MOVDconst [0]) (CMPWUconst [64] y))
(Rsh(64|32)Ux16 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SR(D|W) <t> x y) (MOVDconst [0]) (CMPWUconst [64] (MOVHZreg y)))
(Rsh(64|32)Ux8 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SR(D|W) <t> x y) (MOVDconst [0]) (CMPWUconst [64] (MOVBZreg y)))
(Rsh(16|8)Ux64 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SRW <t> (MOV(H|B)Zreg x) y) (MOVDconst [0]) (CMPUconst [64] y))
(Rsh(16|8)Ux32 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SRW <t> (MOV(H|B)Zreg x) y) (MOVDconst [0]) (CMPWUconst [64] y))
(Rsh(16|8)Ux16 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SRW <t> (MOV(H|B)Zreg x) y) (MOVDconst [0]) (CMPWUconst [64] (MOVHZreg y)))
(Rsh(16|8)Ux8 <t> x y) => (LOCGR <t> {s390x.GreaterOrEqual} (SRW <t> (MOV(H|B)Zreg x) y) (MOVDconst [0]) (CMPWUconst [64] (MOVBZreg y)))
(Rsh(64|32)x64 x y) => (SRA(D|W) x (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPUconst [64] y)))
(Rsh(64|32)x32 x y) => (SRA(D|W) x (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPWUconst [64] y)))
(Rsh(64|32)x16 x y) => (SRA(D|W) x (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPWUconst [64] (MOVHZreg y))))
(Rsh(64|32)x8 x y) => (SRA(D|W) x (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPWUconst [64] (MOVBZreg y))))
(Rsh(16|8)x64 x y) => (SRAW (MOV(H|B)reg x) (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPUconst [64] y)))
(Rsh(16|8)x32 x y) => (SRAW (MOV(H|B)reg x) (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPWUconst [64] y)))
(Rsh(16|8)x16 x y) => (SRAW (MOV(H|B)reg x) (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPWUconst [64] (MOVHZreg y))))
(Rsh(16|8)x8 x y) => (SRAW (MOV(H|B)reg x) (LOCGR <y.Type> {s390x.GreaterOrEqual} y (MOVDconst <y.Type> [63]) (CMPWUconst [64] (MOVBZreg y))))
(RotateLeft8 <t> x (MOVDconst [c])) => (Or8 (Lsh8x64 <t> x (MOVDconst [c&7])) (Rsh8Ux64 <t> x (MOVDconst [-c&7])))
(RotateLeft16 <t> x (MOVDconst [c])) => (Or16 (Lsh16x64 <t> x (MOVDconst [c&15])) (Rsh16Ux64 <t> x (MOVDconst [-c&15])))
(RotateLeft32 ...) => (RLL ...)
(RotateLeft64 ...) => (RLLG ...)
(Less64 x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
(Less32 x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
(Less(16|8) x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (CMPW (MOV(H|B)reg x) (MOV(H|B)reg y)))
(Less64U x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (CMPU x y))
(Less32U x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (CMPWU x y))
(Less(16|8)U x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (CMPWU (MOV(H|B)Zreg x) (MOV(H|B)Zreg y)))
(Less64F x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
(Less32F x y) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
(Leq64 x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
(Leq32 x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
(Leq(16|8) x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPW (MOV(H|B)reg x) (MOV(H|B)reg y)))
(Leq64U x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPU x y))
(Leq32U x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPWU x y))
(Leq(16|8)U x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPWU (MOV(H|B)Zreg x) (MOV(H|B)Zreg y)))
(Leq64F x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
(Leq32F x y) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
(Eq(64|Ptr) x y) => (LOCGR {s390x.Equal} (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
(Eq32 x y) => (LOCGR {s390x.Equal} (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
(Eq(16|8|B) x y) => (LOCGR {s390x.Equal} (MOVDconst [0]) (MOVDconst [1]) (CMPW (MOV(H|B|B)reg x) (MOV(H|B|B)reg y)))
(Eq64F x y) => (LOCGR {s390x.Equal} (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
(Eq32F x y) => (LOCGR {s390x.Equal} (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
(Neq(64|Ptr) x y) => (LOCGR {s390x.NotEqual} (MOVDconst [0]) (MOVDconst [1]) (CMP x y))
(Neq32 x y) => (LOCGR {s390x.NotEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPW x y))
(Neq(16|8|B) x y) => (LOCGR {s390x.NotEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPW (MOV(H|B|B)reg x) (MOV(H|B|B)reg y)))
(Neq64F x y) => (LOCGR {s390x.NotEqual} (MOVDconst [0]) (MOVDconst [1]) (FCMP x y))
(Neq32F x y) => (LOCGR {s390x.NotEqual} (MOVDconst [0]) (MOVDconst [1]) (FCMPS x y))
(Load <t> ptr mem) && (is64BitInt(t) || isPtr(t)) => (MOVDload ptr mem)
(Load <t> ptr mem) && is32BitInt(t) && isSigned(t) => (MOVWload ptr mem)
(Load <t> ptr mem) && is32BitInt(t) && !isSigned(t) => (MOVWZload ptr mem)
(Load <t> ptr mem) && is16BitInt(t) && isSigned(t) => (MOVHload ptr mem)
(Load <t> ptr mem) && is16BitInt(t) && !isSigned(t) => (MOVHZload ptr mem)
(Load <t> ptr mem) && is8BitInt(t) && isSigned(t) => (MOVBload ptr mem)
(Load <t> ptr mem) && (t.IsBoolean() || (is8BitInt(t) && !isSigned(t))) => (MOVBZload ptr mem)
(Load <t> ptr mem) && is32BitFloat(t) => (FMOVSload ptr mem)
(Load <t> ptr mem) && is64BitFloat(t) => (FMOVDload ptr mem)
(Store {t} ptr val mem) && t.Size() == 8 && is64BitFloat(val.Type) => (FMOVDstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 4 && is32BitFloat(val.Type) => (FMOVSstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 8 => (MOVDstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 4 => (MOVWstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 2 => (MOVHstore ptr val mem)
(Store {t} ptr val mem) && t.Size() == 1 => (MOVBstore ptr val mem)
(Move [0] _ _ mem) => mem
(Move [1] dst src mem) => (MOVBstore dst (MOVBZload src mem) mem)
(Move [2] dst src mem) => (MOVHstore dst (MOVHZload src mem) mem)
(Move [4] dst src mem) => (MOVWstore dst (MOVWZload src mem) mem)
(Move [8] dst src mem) => (MOVDstore dst (MOVDload src mem) mem)
(Move [16] dst src mem) => (MOVDstore [8] dst (MOVDload [8] src mem) (MOVDstore dst (MOVDload src mem) mem))
(Move [24] dst src mem) => (MOVDstore [16] dst (MOVDload [16] src mem) (MOVDstore [8] dst (MOVDload [8] src mem) (MOVDstore dst (MOVDload src mem) mem)))
(Move [3] dst src mem) => (MOVBstore [2] dst (MOVBZload [2] src mem) (MOVHstore dst (MOVHZload src mem) mem))
(Move [5] dst src mem) => (MOVBstore [4] dst (MOVBZload [4] src mem) (MOVWstore dst (MOVWZload src mem) mem))
(Move [6] dst src mem) => (MOVHstore [4] dst (MOVHZload [4] src mem) (MOVWstore dst (MOVWZload src mem) mem))
(Move [7] dst src mem) => (MOVBstore [6] dst (MOVBZload [6] src mem) (MOVHstore [4] dst (MOVHZload [4] src mem) (MOVWstore dst (MOVWZload src mem) mem)))
(Move [s] dst src mem) && s > 0 && s <= 256 && logLargeCopy(v, s) => (MVC [makeValAndOff32(int32(s), 0)] dst src mem)
(Move [s] dst src mem) && s > 256 && s <= 512 && logLargeCopy(v, s) => (MVC [makeValAndOff32(int32(s)-256, 256)] dst src (MVC [makeValAndOff32(256, 0)] dst src mem))
(Move [s] dst src mem) && s > 512 && s <= 768 && logLargeCopy(v, s) => (MVC [makeValAndOff32(int32(s)-512, 512)] dst src (MVC [makeValAndOff32(256, 256)] dst src (MVC [makeValAndOff32(256, 0)] dst src mem)))
(Move [s] dst src mem) && s > 768 && s <= 1024 && logLargeCopy(v, s) => (MVC [makeValAndOff32(int32(s)-768, 768)] dst src (MVC [makeValAndOff32(256, 512)] dst src (MVC [makeValAndOff32(256, 256)] dst src (MVC [makeValAndOff32(256, 0)] dst src mem))))
(Move [s] dst src mem) && s > 1024 && logLargeCopy(v, s) => (LoweredMove [s%256] dst src (ADD <src.Type> src (MOVDconst [(s/256)*256])) mem)
(Zero [0] _ mem) => mem
(Zero [1] destptr mem) => (MOVBstoreconst [0] destptr mem)
(Zero [2] destptr mem) => (MOVHstoreconst [0] destptr mem)
(Zero [4] destptr mem) => (MOVWstoreconst [0] destptr mem)
(Zero [8] destptr mem) => (MOVDstoreconst [0] destptr mem)
(Zero [3] destptr mem) => (MOVBstoreconst [makeValAndOff32(0, 2)] destptr (MOVHstoreconst [0] destptr mem))
(Zero [5] destptr mem) => (MOVBstoreconst [makeValAndOff32(0, 4)] destptr (MOVWstoreconst [0] destptr mem))
(Zero [6] destptr mem) => (MOVHstoreconst [makeValAndOff32(0, 4)] destptr (MOVWstoreconst [0] destptr mem))
(Zero [7] destptr mem) => (MOVWstoreconst [makeValAndOff32(0, 3)] destptr (MOVWstoreconst [0] destptr mem))
(Zero [s] destptr mem) && s > 0 && s <= 1024 => (CLEAR [makeValAndOff32(int32(s), 0)] destptr mem)
(Zero [s] destptr mem) && s > 1024 => (LoweredZero [s%256] destptr (ADDconst <destptr.Type> [(int32(s)/256)*256] destptr) mem)
(Const(64|32|16|8) [val]) => (MOVDconst [int64(val)])
(Const(32|64)F ...) => (FMOV(S|D)const ...)
(ConstNil) => (MOVDconst [0])
(ConstBool [b]) => (MOVDconst [b2i(b)])
(StaticCall ...) => (CALLstatic ...)
(ClosureCall ...) => (CALLclosure ...)
(InterCall ...) => (CALLinter ...)
(IsNonNil p) => (LOCGR {s390x.NotEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPconst [0] p))
(IsInBounds idx len) => (LOCGR {s390x.Less} (MOVDconst [0]) (MOVDconst [1]) (CMPU idx len))
(IsSliceInBounds idx len) => (LOCGR {s390x.LessOrEqual} (MOVDconst [0]) (MOVDconst [1]) (CMPU idx len))
(NilCheck ...) => (LoweredNilCheck ...)
(GetG ...) => (LoweredGetG ...)
(GetClosurePtr ...) => (LoweredGetClosurePtr ...)
(GetCallerSP ...) => (LoweredGetCallerSP ...)
(GetCallerPC ...) => (LoweredGetCallerPC ...)
(Addr {sym} base) => (MOVDaddr {sym} base)
(LocalAddr {sym} base _) => (MOVDaddr {sym} base)
(ITab (Load ptr mem)) => (MOVDload ptr mem)
(If cond yes no) => (CLIJ [0] {s390x.LessOrGreater} (MOVBZreg <typ.Bool> cond) yes no)
(WB ...) => (LoweredWB ...)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 0 => (LoweredPanicBoundsA [kind] x y mem)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 1 => (LoweredPanicBoundsB [kind] x y mem)
(PanicBounds [kind] x y mem) && boundsABI(kind) == 2 => (LoweredPanicBoundsC [kind] x y mem)
(MOV(H|HZ)reg e:(MOV(B|BZ)reg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(W|WZ)reg e:(MOV(B|BZ)reg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(W|WZ)reg e:(MOV(H|HZ)reg x)) && clobberIfDead(e) => (MOV(H|HZ)reg x)
(MOV(B|BZ)reg e:(MOVBreg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(B|BZ)reg e:(MOVHreg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(B|BZ)reg e:(MOVWreg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(H|HZ)reg e:(MOVHreg x)) && clobberIfDead(e) => (MOV(H|HZ)reg x)
(MOV(H|HZ)reg e:(MOVWreg x)) && clobberIfDead(e) => (MOV(H|HZ)reg x)
(MOV(W|WZ)reg e:(MOVWreg x)) && clobberIfDead(e) => (MOV(W|WZ)reg x)
(MOV(B|BZ)reg e:(MOVBZreg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(B|BZ)reg e:(MOVHZreg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(B|BZ)reg e:(MOVWZreg x)) && clobberIfDead(e) => (MOV(B|BZ)reg x)
(MOV(H|HZ)reg e:(MOVHZreg x)) && clobberIfDead(e) => (MOV(H|HZ)reg x)
(MOV(H|HZ)reg e:(MOVWZreg x)) && clobberIfDead(e) => (MOV(H|HZ)reg x)
(MOV(W|WZ)reg e:(MOVWZreg x)) && clobberIfDead(e) => (MOV(W|WZ)reg x)
(MOV(B|H|W)Zreg x:(MOVBZload _ _)) && (!x.Type.IsSigned() || x.Type.Size() > 1) => x
(MOV(H|W)Zreg x:(MOVHZload _ _)) && (!x.Type.IsSigned() || x.Type.Size() > 2) => x
(MOVWZreg x:(MOVWZload _ _)) && (!x.Type.IsSigned() || x.Type.Size() > 4) => x
(MOV(B|H|W)reg x:(MOVBload _ _)) && (x.Type.IsSigned() || x.Type.Size() == 8) => x
(MOV(H|W)reg x:(MOVHload _ _)) && (x.Type.IsSigned() || x.Type.Size() == 8) => x
(MOVWreg x:(MOVWload _ _)) && (x.Type.IsSigned() || x.Type.Size() == 8) => x
(MOV(H|W)reg x:(MOVBZload _ _)) && (!x.Type.IsSigned() || x.Type.Size() > 1) => x
(MOVWreg x:(MOVHZload _ _)) && (!x.Type.IsSigned() || x.Type.Size() > 2) => x
(MOV(B|H|W)Zreg <t> x:(MOV(B|H|W)load [o] {s} p mem)) && x.Uses == 1 && clobber(x) => @x.Block (MOV(B|H|W)Zload <t> [o] {s} p mem)
(MOV(B|H|W)reg <t> x:(MOV(B|H|W)Zload [o] {s} p mem)) && x.Uses == 1 && clobber(x) => @x.Block (MOV(B|H|W)load <t> [o] {s} p mem)
(MOVBZreg x:(Arg <t>)) && !t.IsSigned() && t.Size() == 1 => x
(MOVHZreg x:(Arg <t>)) && !t.IsSigned() && t.Size() <= 2 => x
(MOVWZreg x:(Arg <t>)) && !t.IsSigned() && t.Size() <= 4 => x
(MOVBreg x:(Arg <t>)) && t.IsSigned() && t.Size() == 1 => x
(MOVHreg x:(Arg <t>)) && t.IsSigned() && t.Size() <= 2 => x
(MOVWreg x:(Arg <t>)) && t.IsSigned() && t.Size() <= 4 => x
(MOVBZreg (MOVDconst [c])) => (MOVDconst [int64(uint8(c))])
(MOVHZreg (MOVDconst [c])) => (MOVDconst [int64(uint16(c))])
(MOVWZreg (MOVDconst [c])) => (MOVDconst [int64(uint32(c))])
(MOVBreg (MOVDconst [c])) => (MOVDconst [int64(int8(c))])
(MOVHreg (MOVDconst [c])) => (MOVDconst [int64(int16(c))])
(MOVWreg (MOVDconst [c])) => (MOVDconst [int64(int32(c))])
(MOVBZreg x:(LOCGR (MOVDconst [c]) (MOVDconst [d]) _)) && int64(uint8(c)) == c && int64(uint8(d)) == d && (!x.Type.IsSigned() || x.Type.Size() > 1) => x
(CLIJ [0] {s390x.LessOrGreater} (LOCGR {d} (MOVDconst [0]) (MOVDconst [x]) cmp) yes no) && int32(x) != 0 => (BRC {d} cmp yes no)
(BRC {c} x:((CMP|CMPW|CMPU|CMPWU) _ _) yes no) && c&s390x.Unordered != 0 => (BRC {c&^s390x.Unordered} x yes no)
(BRC {c} x:((CMP|CMPW|CMPU|CMPWU)const _) yes no) && c&s390x.Unordered != 0 => (BRC {c&^s390x.Unordered} x yes no)
(BRC {c} (CMP x y) yes no) => (CGRJ {c&^s390x.Unordered} x y yes no)
(BRC {c} (CMPW x y) yes no) => (CRJ {c&^s390x.Unordered} x y yes no)
(BRC {c} (CMPU x y) yes no) => (CLGRJ {c&^s390x.Unordered} x y yes no)
(BRC {c} (CMPWU x y) yes no) => (CLRJ {c&^s390x.Unordered} x y yes no)
(BRC {c} (CMPconst [y] x) yes no) && y == int32(int8(y)) => (CGIJ [int8(y)] {c&^s390x.Unordered} x yes no)
(BRC {c} (CMPWconst [y] x) yes no) && y == int32(int8(y)) => (CIJ [int8(y)] {c&^s390x.Unordered} x yes no)
(BRC {c} (CMPUconst [y] x) yes no) && y == int32(uint8(y)) => (CLGIJ [uint8(y)] {c&^s390x.Unordered} x yes no)
(BRC {c} (CMPWUconst [y] x) yes no) && y == int32(uint8(y)) => (CLIJ [uint8(y)] {c&^s390x.Unordered} x yes no)
(C(R|GR)J {c} x (MOVDconst [y]) yes no) && is8Bit(y) => (C(I|GI)J [int8(y)] {c} x yes no)
(CL(R|GR)J {c} x (MOVDconst [y]) yes no) && isU8Bit(y) => (CL(I|GI)J [uint8(y)] {c} x yes no)
(C(R|GR)J {c} (MOVDconst [x]) y yes no) && is8Bit(x) => (C(I|GI)J [int8(x)] {c.ReverseComparison()} y yes no)
(CL(R|GR)J {c} (MOVDconst [x]) y yes no) && isU8Bit(x) => (CL(I|GI)J [uint8(x)] {c.ReverseComparison()} y yes no)
(CGRJ {c} x (MOVDconst [y]) yes no) && !is8Bit(y) && is32Bit(y) => (BRC {c} (CMPconst [int32(y)] x) yes no)
(CRJ {c} x (MOVDconst [y]) yes no) && !is8Bit(y) && is32Bit(y) => (BRC {c} (CMPWconst [int32(y)] x) yes no)
(CLGRJ {c} x (MOVDconst [y]) yes no) && !isU8Bit(y) && isU32Bit(y) => (BRC {c} (CMPUconst [int32(y)] x) yes no)
(CLRJ {c} x (MOVDconst [y]) yes no) && !isU8Bit(y) && isU32Bit(y) => (BRC {c} (CMPWUconst [int32(y)] x) yes no)
(CGRJ {c} (MOVDconst [x]) y yes no) && !is8Bit(x) && is32Bit(x) => (BRC {c.ReverseComparison()} (CMPconst [int32(x)] y) yes no)
(CRJ {c} (MOVDconst [x]) y yes no) && !is8Bit(x) && is32Bit(x) => (BRC {c.ReverseComparison()} (CMPWconst [int32(x)] y) yes no)
(CLGRJ {c} (MOVDconst [x]) y yes no) && !isU8Bit(x) && isU32Bit(x) => (BRC {c.ReverseComparison()} (CMPUconst [int32(x)] y) yes no)
(CLRJ {c} (MOVDconst [x]) y yes no) && !isU8Bit(x) && isU32Bit(x) => (BRC {c.ReverseComparison()} (CMPWUconst [int32(x)] y) yes no)
(CIJ [y] {c} (MOV(W|WZ)reg x) yes no) => (CIJ [y] {c} x yes no)
(CLIJ [y] {c} (MOV(W|WZ)reg x) yes no) => (CLIJ [y] {c} x yes no)
(BRC {s390x.Less} (CMPconst [128] x) yes no) => (CGIJ [127] {s390x.LessOrEqual} x yes no)
(BRC {s390x.Less} (CMPWconst [128] x) yes no) => (CIJ [127] {s390x.LessOrEqual} x yes no)
(BRC {s390x.LessOrEqual} (CMPconst [-129] x) yes no) => (CGIJ [-128] {s390x.Less} x yes no)
(BRC {s390x.LessOrEqual} (CMPWconst [-129] x) yes no) => (CIJ [-128] {s390x.Less} x yes no)
(BRC {s390x.Greater} (CMPconst [-129] x) yes no) => (CGIJ [-128] {s390x.GreaterOrEqual} x yes no)
(BRC {s390x.Greater} (CMPWconst [-129] x) yes no) => (CIJ [-128] {s390x.GreaterOrEqual} x yes no)
(BRC {s390x.GreaterOrEqual} (CMPconst [128] x) yes no) => (CGIJ [127] {s390x.Greater} x yes no)
(BRC {s390x.GreaterOrEqual} (CMPWconst [128] x) yes no) => (CIJ [127] {s390x.Greater} x yes no)
(BRC {s390x.Less} (CMP(WU|U)const [256] x) yes no) => (C(L|LG)IJ [255] {s390x.LessOrEqual} x yes no)
(BRC {s390x.GreaterOrEqual} (CMP(WU|U)const [256] x) yes no) => (C(L|LG)IJ [255] {s390x.Greater} x yes no)
(BRC {c} (CMPconst [y] x) yes no) && y == int32(uint8(y)) && (c == s390x.Equal || c == s390x.LessOrGreater) => (CLGIJ [uint8(y)] {c} x yes no)
(BRC {c} (CMPWconst [y] x) yes no) && y == int32(uint8(y)) && (c == s390x.Equal || c == s390x.LessOrGreater) => (CLIJ [uint8(y)] {c} x yes no)
(BRC {c} (CMPUconst [y] x) yes no) && y == int32(int8(y)) && (c == s390x.Equal || c == s390x.LessOrGreater) => (CGIJ [int8(y)] {c} x yes no)
(BRC {c} (CMPWUconst [y] x) yes no) && y == int32(int8(y)) && (c == s390x.Equal || c == s390x.LessOrGreater) => (CIJ [int8(y)] {c} x yes no)
(ADD x (MOVDconst [c])) && is32Bit(c) => (ADDconst [int32(c)] x)
(ADDW x (MOVDconst [c])) => (ADDWconst [int32(c)] x)
(SUB x (MOVDconst [c])) && is32Bit(c) => (SUBconst [int32(c)] x)
(SUB (MOVDconst [c]) x) && is32Bit(c) => (NEG (SUBconst <v.Type> [int32(c)] x))
(SUBW x (MOVDconst [c])) => (SUBWconst [int32(c)] x)
(SUBW (MOVDconst [c]) x) => (NEGW (SUBWconst <v.Type> [int32(c)] x))
(MULLD x (MOVDconst [c])) && is32Bit(c) => (MULLDconst [int32(c)] x)
(MULLW x (MOVDconst [c])) => (MULLWconst [int32(c)] x)
(AND x (MOVDconst [c])) && s390x.NewRotateParams(0, 63, 0).OutMerge(uint64(c)) != nil => (RISBGZ {*s390x.NewRotateParams(0, 63, 0).OutMerge(uint64(c))} x)
(AND x (MOVDconst [c])) && is32Bit(c) && c < 0 => (ANDconst [c] x)
(AND x (MOVDconst [c])) && is32Bit(c) && c >= 0 => (MOVWZreg (ANDWconst <typ.UInt32> [int32(c)] x))
(ANDW x (MOVDconst [c])) => (ANDWconst [int32(c)] x)
((AND|ANDW)const [c] ((AND|ANDW)const [d] x)) => ((AND|ANDW)const [c&d] x)
((OR|XOR) x (MOVDconst [c])) && isU32Bit(c) => ((OR|XOR)const [c] x)
((OR|XOR)W x (MOVDconst [c])) => ((OR|XOR)Wconst [int32(c)] x)
(S(LD|RD|RAD) x (MOVDconst [c])) => (S(LD|RD|RAD)const [uint8(c&63)] x)
(S(LW|RW|RAW) x (MOVDconst [c])) && c&32 == 0 => (S(LW|RW|RAW)const [uint8(c&31)] x)
(S(LW|RW) _ (MOVDconst [c])) && c&32 != 0 => (MOVDconst [0])
(SRAW x (MOVDconst [c])) && c&32 != 0 => (SRAWconst [31] x)
(S(LD|RD|RAD|LW|RW|RAW) x (RISBGZ {r} y)) && r.Amount == 0 && r.OutMask()&63 == 63 => (S(LD|RD|RAD|LW|RW|RAW) x y)
(S(LD|RD|RAD|LW|RW|RAW) x (AND (MOVDconst [c]) y)) => (S(LD|RD|RAD|LW|RW|RAW) x (ANDWconst <typ.UInt32> [int32(c&63)] y))
(S(LD|RD|RAD|LW|RW|RAW) x (ANDWconst [c] y)) && c&63 == 63 => (S(LD|RD|RAD|LW|RW|RAW) x y)
(SLD x (MOV(W|H|B|WZ|HZ|BZ)reg y)) => (SLD x y)
(SRD x (MOV(W|H|B|WZ|HZ|BZ)reg y)) => (SRD x y)
(SRAD x (MOV(W|H|B|WZ|HZ|BZ)reg y)) => (SRAD x y)
(SLW x (MOV(W|H|B|WZ|HZ|BZ)reg y)) => (SLW x y)
(SRW x (MOV(W|H|B|WZ|HZ|BZ)reg y)) => (SRW x y)
(SRAW x (MOV(W|H|B|WZ|HZ|BZ)reg y)) => (SRAW x y)
(RLLG x (MOVDconst [c])) => (RISBGZ {s390x.NewRotateParams(0, 63, uint8(c&63))} x)
(RLL x (MOVDconst [c])) => (RLLconst [uint8(c&31)] x)
((ADD|OR|XOR) (SLDconst [c] x) (SRDconst [64-c] x)) => (RISBGZ {s390x.NewRotateParams(0, 63, c)} x)
((ADD|OR|XOR)W (SLWconst [c] x) (SRWconst [32-c] x)) => (RLLconst [c] x)
(CMP x (MOVDconst [c])) && is32Bit(c) => (CMPconst [int32(c)] x)
(CMP (MOVDconst [c]) x) && is32Bit(c) => (InvertFlags (CMPconst [int32(c)] x))
(CMPU x (MOVDconst [c])) && isU32Bit(c) => (CMPUconst [int32(c)] x)
(CMPU (MOVDconst [c]) x) && isU32Bit(c) => (InvertFlags (CMPUconst [int32(c)] x))
(CMP(W|WU) x (MOVDconst [c])) => (CMP(W|WU)const [int32(c)] x)
(CMP(W|WU) (MOVDconst [c]) x) => (InvertFlags (CMP(W|WU)const [int32(c)] x))
(SLDconst [d] (SRDconst [c] x)) => (RISBGZ {s390x.NewRotateParams(uint8(max8(0, int8(c-d))), 63-d, uint8(int8(d-c)&63))} x)
(SRDconst [d] (SLDconst [c] x)) => (RISBGZ {s390x.NewRotateParams(d, uint8(min8(63, int8(63-c+d))), uint8(int8(c-d)&63))} x)
(RISBGZ {r} (MOVWZreg x)) && r.InMerge(0xffffffff) != nil => (RISBGZ {*r.InMerge(0xffffffff)} x)
(RISBGZ {r} (MOVHZreg x)) && r.InMerge(0x0000ffff) != nil => (RISBGZ {*r.InMerge(0x0000ffff)} x)
(RISBGZ {r} (MOVBZreg x)) && r.InMerge(0x000000ff) != nil => (RISBGZ {*r.InMerge(0x000000ff)} x)
(MOVWZreg (RISBGZ {r} x)) && r.OutMerge(0xffffffff) != nil => (RISBGZ {*r.OutMerge(0xffffffff)} x)
(MOVHZreg (RISBGZ {r} x)) && r.OutMerge(0x0000ffff) != nil => (RISBGZ {*r.OutMerge(0x0000ffff)} x)
(MOVBZreg (RISBGZ {r} x)) && r.OutMerge(0x000000ff) != nil => (RISBGZ {*r.OutMerge(0x000000ff)} x)
(RISBGZ {r} (SLDconst [c] x)) && r.InMerge(^uint64(0)<<c) != nil => (RISBGZ {(*r.InMerge(^uint64(0)<<c)).RotateLeft(c)} x)
(RISBGZ {r} (SRDconst [c] x)) && r.InMerge(^uint64(0)>>c) != nil => (RISBGZ {(*r.InMerge(^uint64(0)>>c)).RotateLeft(-c)} x)
(SLDconst [c] (RISBGZ {r} x)) && s390x.NewRotateParams(0, 63-c, c).InMerge(r.OutMask()) != nil => (RISBGZ {(*s390x.NewRotateParams(0, 63-c, c).InMerge(r.OutMask())).RotateLeft(r.Amount)} x)
(SRDconst [c] (RISBGZ {r} x)) && s390x.NewRotateParams(c, 63, -c&63).InMerge(r.OutMask()) != nil => (RISBGZ {(*s390x.NewRotateParams(c, 63, -c&63).InMerge(r.OutMask())).RotateLeft(r.Amount)} x)
(RISBGZ {z} (RISBGZ {y} x)) && z.InMerge(y.OutMask()) != nil => (RISBGZ {(*z.InMerge(y.OutMask())).RotateLeft(y.Amount)} x)
(RISBGZ {r} x) && r.End == 63 && r.Start == -r.Amount&63 => (SRDconst [-r.Amount&63] x)
(RISBGZ {r} x) && r.Start == 0 && r.End == 63-r.Amount => (SLDconst [r.Amount] x)
(RISBGZ {r} (SRADconst [c] x)) && r.Start == r.End => (RISBGZ {s390x.NewRotateParams(r.Start, r.Start, -r.Start&63)} x)
((CMP|CMPW|CMPU|CMPWU) x y) && x.ID > y.ID => (InvertFlags ((CMP|CMPW|CMPU|CMPWU) y x))
(RISBGZ {r} x) && r == s390x.NewRotateParams(56, 63, 0) => (MOVBZreg x)
(RISBGZ {r} x) && r == s390x.NewRotateParams(48, 63, 0) => (MOVHZreg x)
(RISBGZ {r} x) && r == s390x.NewRotateParams(32, 63, 0) => (MOVWZreg x)
(ANDWconst [0x00ff] x) => (MOVBZreg x)
(ANDWconst [0xffff] x) => (MOVHZreg x)
(MULL(D|W)const <t> [c] x) && isPowerOfTwo32(c&(c-1)) => ((ADD|ADDW) (SL(D|W)const <t> [uint8(log32(c&(c-1)))] x) (SL(D|W)const <t> [uint8(log32(c&^(c-1)))] x))
(MULL(D|W)const <t> [c] x) && isPowerOfTwo32(c+(c&^(c-1))) => ((SUB|SUBW) (SL(D|W)const <t> [uint8(log32(c+(c&^(c-1))))] x) (SL(D|W)const <t> [uint8(log32(c&^(c-1)))] x))
(MULL(D|W)const <t> [c] x) && isPowerOfTwo32(-c+(-c&^(-c-1))) => ((SUB|SUBW) (SL(D|W)const <t> [uint8(log32(-c&^(-c-1)))] x) (SL(D|W)const <t> [uint8(log32(-c+(-c&^(-c-1))))] x))
(ADDconst [c] (MOVDaddr [d] {s} x:(SB))) && ((c+d)&1 == 0) && is32Bit(int64(c)+int64(d)) => (MOVDaddr [c+d] {s} x)
(ADDconst [c] (MOVDaddr [d] {s} x)) && x.Op != OpSB && is20Bit(int64(c)+int64(d)) => (MOVDaddr [c+d] {s} x)
(ADD idx (MOVDaddr [c] {s} ptr)) && ptr.Op != OpSB => (MOVDaddridx [c] {s} ptr idx)
(ADDconst [c] (MOVDaddridx [d] {s} x y)) && is20Bit(int64(c)+int64(d)) => (MOVDaddridx [c+d] {s} x y)
(MOVDaddridx [c] {s} (ADDconst [d] x) y) && is20Bit(int64(c)+int64(d)) => (MOVDaddridx [c+d] {s} x y)
(MOVDaddridx [c] {s} x (ADDconst [d] y)) && is20Bit(int64(c)+int64(d)) => (MOVDaddridx [c+d] {s} x y)
(LOCGR {c} x y (InvertFlags cmp)) => (LOCGR {c.ReverseComparison()} x y cmp)
(MOVDload [off] {sym} ptr1 (MOVDstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => x
(MOVWload [off] {sym} ptr1 (MOVWstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (MOVWreg x)
(MOVHload [off] {sym} ptr1 (MOVHstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (MOVHreg x)
(MOVBload [off] {sym} ptr1 (MOVBstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (MOVBreg x)
(MOVWZload [off] {sym} ptr1 (MOVWstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (MOVWZreg x)
(MOVHZload [off] {sym} ptr1 (MOVHstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (MOVHZreg x)
(MOVBZload [off] {sym} ptr1 (MOVBstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (MOVBZreg x)
(MOVDload [off] {sym} ptr1 (FMOVDstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (LGDR x)
(FMOVDload [off] {sym} ptr1 (MOVDstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => (LDGR x)
(FMOVDload [off] {sym} ptr1 (FMOVDstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => x
(FMOVSload [off] {sym} ptr1 (FMOVSstore [off] {sym} ptr2 x _)) && isSamePtr(ptr1, ptr2) => x
(MULLDload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _)) && isSamePtr(ptr1, ptr2) => (MULLD x (LGDR <t> y))
(ADDload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _)) && isSamePtr(ptr1, ptr2) => (ADD x (LGDR <t> y))
(SUBload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _)) && isSamePtr(ptr1, ptr2) => (SUB x (LGDR <t> y))
(ORload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _)) && isSamePtr(ptr1, ptr2) => (OR x (LGDR <t> y))
(ANDload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _)) && isSamePtr(ptr1, ptr2) => (AND x (LGDR <t> y))
(XORload <t> [off] {sym} x ptr1 (FMOVDstore [off] {sym} ptr2 y _)) && isSamePtr(ptr1, ptr2) => (XOR x (LGDR <t> y))
(RISBGZ {r} (LGDR <t> x)) && r == s390x.NewRotateParams(1, 63, 0) => (LGDR <t> (LPDFR <x.Type> x))
(LDGR <t> (RISBGZ {r} x)) && r == s390x.NewRotateParams(1, 63, 0) => (LPDFR (LDGR <t> x))
(OR (MOVDconst [-1<<63]) (LGDR <t> x)) => (LGDR <t> (LNDFR <x.Type> x))
(LDGR <t> (OR (MOVDconst [-1<<63]) x)) => (LNDFR (LDGR <t> x))
(LDGR <t> x:(ORload <t1> [off] {sym} (MOVDconst [-1<<63]) ptr mem)) && x.Uses == 1 && clobber(x) => @x.Block (LNDFR <t> (LDGR <t> (MOVDload <t1> [off] {sym} ptr mem)))
(OR (RISBGZ {r} (LGDR x)) (LGDR (LPDFR <t> y))) && r == s390x.NewRotateParams(0, 0, 0) => (LGDR (CPSDR <t> y x))
(OR (RISBGZ {r} (LGDR x)) (MOVDconst [c])) && c >= 0 && r == s390x.NewRotateParams(0, 0, 0) => (LGDR (CPSDR <x.Type> (FMOVDconst <x.Type> [math.Float64frombits(uint64(c))]) x))
(CPSDR y (FMOVDconst [c])) && !math.Signbit(c) => (LPDFR y)
(CPSDR y (FMOVDconst [c])) && math.Signbit(c) => (LNDFR y)
(FNEG (LPDFR x)) => (LNDFR x)
(FNEG (LNDFR x)) => (LPDFR x)
(FNEGS (LPDFR x)) => (LNDFR x)
(FNEGS (LNDFR x)) => (LPDFR x)
(LEDBR (LPDFR (LDEBR x))) => (LPDFR x)
(LEDBR (LNDFR (LDEBR x))) => (LNDFR x)
(LDGR (LGDR x)) => x
(LGDR (LDGR x)) => x
(MOVWstore [off] {sym} ptr (MOVWreg x) mem) => (MOVWstore [off] {sym} ptr x mem)
(MOVHstore [off] {sym} ptr (MOVHreg x) mem) => (MOVHstore [off] {sym} ptr x mem)
(MOVBstore [off] {sym} ptr (MOVBreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
(MOVWstore [off] {sym} ptr (MOVWZreg x) mem) => (MOVWstore [off] {sym} ptr x mem)
(MOVHstore [off] {sym} ptr (MOVHZreg x) mem) => (MOVHstore [off] {sym} ptr x mem)
(MOVBstore [off] {sym} ptr (MOVBZreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
(MOVDload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (MOVDload [off1+off2] {sym} ptr mem)
(MOVWload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (MOVWload [off1+off2] {sym} ptr mem)
(MOVHload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (MOVHload [off1+off2] {sym} ptr mem)
(MOVBload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (MOVBload [off1+off2] {sym} ptr mem)
(MOVWZload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (MOVWZload [off1+off2] {sym} ptr mem)
(MOVHZload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (MOVHZload [off1+off2] {sym} ptr mem)
(MOVBZload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (MOVBZload [off1+off2] {sym} ptr mem)
(FMOVSload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (FMOVSload [off1+off2] {sym} ptr mem)
(FMOVDload [off1] {sym} (ADDconst [off2] ptr) mem) && is20Bit(int64(off1)+int64(off2)) => (FMOVDload [off1+off2] {sym} ptr mem)
(MOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is20Bit(int64(off1)+int64(off2)) => (MOVDstore [off1+off2] {sym} ptr val mem)
(MOVWstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is20Bit(int64(off1)+int64(off2)) => (MOVWstore [off1+off2] {sym} ptr val mem)
(MOVHstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is20Bit(int64(off1)+int64(off2)) => (MOVHstore [off1+off2] {sym} ptr val mem)
(MOVBstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is20Bit(int64(off1)+int64(off2)) => (MOVBstore [off1+off2] {sym} ptr val mem)
(FMOVSstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is20Bit(int64(off1)+int64(off2)) => (FMOVSstore [off1+off2] {sym} ptr val mem)
(FMOVDstore [off1] {sym} (ADDconst [off2] ptr) val mem) && is20Bit(int64(off1)+int64(off2)) => (FMOVDstore [off1+off2] {sym} ptr val mem)
(ADDload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (ADDload [off1+off2] {sym} x ptr mem)
(ADDWload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (ADDWload [off1+off2] {sym} x ptr mem)
(MULLDload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (MULLDload [off1+off2] {sym} x ptr mem)
(MULLWload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (MULLWload [off1+off2] {sym} x ptr mem)
(SUBload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (SUBload [off1+off2] {sym} x ptr mem)
(SUBWload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (SUBWload [off1+off2] {sym} x ptr mem)
(ANDload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (ANDload [off1+off2] {sym} x ptr mem)
(ANDWload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (ANDWload [off1+off2] {sym} x ptr mem)
(ORload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (ORload [off1+off2] {sym} x ptr mem)
(ORWload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (ORWload [off1+off2] {sym} x ptr mem)
(XORload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (XORload [off1+off2] {sym} x ptr mem)
(XORWload [off1] {sym} x (ADDconst [off2] ptr) mem) && ptr.Op != OpSB && is20Bit(int64(off1)+int64(off2)) => (XORWload [off1+off2] {sym} x ptr mem)
(MOVDstore [off] {sym} ptr (MOVDconst [c]) mem) && is16Bit(c) && isU12Bit(int64(off)) && ptr.Op != OpSB => (MOVDstoreconst [makeValAndOff32(int32(c), off)] {sym} ptr mem)
(MOVWstore [off] {sym} ptr (MOVDconst [c]) mem) && is16Bit(c) && isU12Bit(int64(off)) && ptr.Op != OpSB => (MOVWstoreconst [makeValAndOff32(int32(c), off)] {sym} ptr mem)
(MOVHstore [off] {sym} ptr (MOVDconst [c]) mem) && isU12Bit(int64(off)) && ptr.Op != OpSB => (MOVHstoreconst [makeValAndOff32(int32(int16(c)), off)] {sym} ptr mem)
(MOVBstore [off] {sym} ptr (MOVDconst [c]) mem) && is20Bit(int64(off)) && ptr.Op != OpSB => (MOVBstoreconst [makeValAndOff32(int32(int8(c)), off)] {sym} ptr mem)
(MOVDstoreconst [sc] {s} (ADDconst [off] ptr) mem) && isU12Bit(sc.Off()+int64(off)) => (MOVDstoreconst [sc.addOffset32(off)] {s} ptr mem)
(MOVWstoreconst [sc] {s} (ADDconst [off] ptr) mem) && isU12Bit(sc.Off()+int64(off)) => (MOVWstoreconst [sc.addOffset32(off)] {s} ptr mem)
(MOVHstoreconst [sc] {s} (ADDconst [off] ptr) mem) && isU12Bit(sc.Off()+int64(off)) => (MOVHstoreconst [sc.addOffset32(off)] {s} ptr mem)
(MOVBstoreconst [sc] {s} (ADDconst [off] ptr) mem) && is20Bit(sc.Off()+int64(off)) => (MOVBstoreconst [sc.addOffset32(off)] {s} ptr mem)
(MOVDload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%8 == 0 && (off1+off2)%8 == 0)) => (MOVDload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(MOVWZload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%4 == 0 && (off1+off2)%4 == 0)) => (MOVWZload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(MOVHZload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%2 == 0 && (off1+off2)%2 == 0)) => (MOVHZload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(MOVBZload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (MOVBZload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(FMOVSload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (FMOVSload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(FMOVDload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (FMOVDload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(MOVWload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%4 == 0 && (off1+off2)%4 == 0)) => (MOVWload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(MOVHload [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%2 == 0 && (off1+off2)%2 == 0)) => (MOVHload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(MOVBload [off1] {sym1} (MOVDaddr [off2] {sym2} base) mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (MOVBload [off1+off2] {mergeSym(sym1,sym2)} base mem)
(MOVDstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%8 == 0 && (off1+off2)%8 == 0)) => (MOVDstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
(MOVWstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%4 == 0 && (off1+off2)%4 == 0)) => (MOVWstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
(MOVHstore [off1] {sym1} (MOVDaddr <t> [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && (base.Op != OpSB || (t.IsPtr() && t.Elem().Alignment()%2 == 0 && (off1+off2)%2 == 0)) => (MOVHstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
(MOVBstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (MOVBstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
(FMOVSstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (FMOVSstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
(FMOVDstore [off1] {sym1} (MOVDaddr [off2] {sym2} base) val mem) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) => (FMOVDstore [off1+off2] {mergeSym(sym1,sym2)} base val mem)
(ADDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (ADDload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(ADDWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (ADDWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(MULLDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (MULLDload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(MULLWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (MULLWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(SUBload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (SUBload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(SUBWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (SUBWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(ANDload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (ANDload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(ANDWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (ANDWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(ORload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (ORload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(ORWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (ORWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(XORload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (XORload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(XORWload [o1] {s1} x (MOVDaddr [o2] {s2} ptr) mem) && ptr.Op != OpSB && is20Bit(int64(o1)+int64(o2)) && canMergeSym(s1, s2) => (XORWload [o1+o2] {mergeSym(s1, s2)} x ptr mem)
(MOVDstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem) && ptr.Op != OpSB && canMergeSym(sym1, sym2) && sc.canAdd32(off) => (MOVDstoreconst [sc.addOffset32(off)] {mergeSym(sym1, sym2)} ptr mem)
(MOVWstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem) && ptr.Op != OpSB && canMergeSym(sym1, sym2) && sc.canAdd32(off) => (MOVWstoreconst [sc.addOffset32(off)] {mergeSym(sym1, sym2)} ptr mem)
(MOVHstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem) && ptr.Op != OpSB && canMergeSym(sym1, sym2) && sc.canAdd32(off) => (MOVHstoreconst [sc.addOffset32(off)] {mergeSym(sym1, sym2)} ptr mem)
(MOVBstoreconst [sc] {sym1} (MOVDaddr [off] {sym2} ptr) mem) && ptr.Op != OpSB && canMergeSym(sym1, sym2) && sc.canAdd32(off) => (MOVBstoreconst [sc.addOffset32(off)] {mergeSym(sym1, sym2)} ptr mem)
(MOVDaddridx [off1] {sym1} (MOVDaddr [off2] {sym2} x) y) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && x.Op != OpSB => (MOVDaddridx [off1+off2] {mergeSym(sym1,sym2)} x y)
(MOVDaddridx [off1] {sym1} x (MOVDaddr [off2] {sym2} y)) && is32Bit(int64(off1)+int64(off2)) && canMergeSym(sym1, sym2) && y.Op != OpSB => (MOVDaddridx [off1+off2] {mergeSym(sym1,sym2)} x y)
(BRC {c} (InvertFlags cmp) yes no) => (BRC {c.ReverseComparison()} cmp yes no)
(CMPconst [y] (MOVDconst [x])) && x == int64(y) => (FlagEQ)
(CMPconst [y] (MOVDconst [x])) && x < int64(y) => (FlagLT)
(CMPconst [y] (MOVDconst [x])) && x > int64(y) => (FlagGT)
(CMPUconst [y] (MOVDconst [x])) && uint64(x) == uint64(y) => (FlagEQ)
(CMPUconst [y] (MOVDconst [x])) && uint64(x) < uint64(y) => (FlagLT)
(CMPUconst [y] (MOVDconst [x])) && uint64(x) > uint64(y) => (FlagGT)
(CMPWconst [y] (MOVDconst [x])) && int32(x) == int32(y) => (FlagEQ)
(CMPWconst [y] (MOVDconst [x])) && int32(x) < int32(y) => (FlagLT)
(CMPWconst [y] (MOVDconst [x])) && int32(x) > int32(y) => (FlagGT)
(CMPWUconst [y] (MOVDconst [x])) && uint32(x) == uint32(y) => (FlagEQ)
(CMPWUconst [y] (MOVDconst [x])) && uint32(x) < uint32(y) => (FlagLT)
(CMPWUconst [y] (MOVDconst [x])) && uint32(x) > uint32(y) => (FlagGT)
(CMP(W|WU)const [c] (MOVBZreg _)) && 0xff < c => (FlagLT)
(CMP(W|WU)const [c] (MOVHZreg _)) && 0xffff < c => (FlagLT)
(CMPconst [n] (SRDconst [c] _)) && c > 0 && n < 0 => (FlagGT)
(CMPWconst [n] (SRWconst [c] _)) && c > 0 && n < 0 => (FlagGT)
(CMPUconst [n] (SRDconst [c] _)) && c > 0 && c < 64 && (1<<uint(64-c)) <= uint64(n) => (FlagLT)
(CMPWUconst [n] (SRWconst [c] _)) && c > 0 && c < 32 && (1<<uint(32-c)) <= uint32(n) => (FlagLT)
(CMPWconst [n] (ANDWconst [m] _)) && int32(m) >= 0 && int32(m) < int32(n) => (FlagLT)
(CMPWUconst [n] (ANDWconst [m] _)) && uint32(m) < uint32(n) => (FlagLT)
(CMPconst [c] (RISBGZ {r} x)) && c > 0 && r.OutMask() < uint64(c) => (FlagLT)
(CMPUconst [c] (RISBGZ {r} x)) && r.OutMask() < uint64(uint32(c)) => (FlagLT)
(CGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal != 0 && int64(x) == int64(y) => (First yes no)
(CGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less != 0 && int64(x) < int64(y) => (First yes no)
(CGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater != 0 && int64(x) > int64(y) => (First yes no)
(CIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal != 0 && int32(x) == int32(y) => (First yes no)
(CIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less != 0 && int32(x) < int32(y) => (First yes no)
(CIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater != 0 && int32(x) > int32(y) => (First yes no)
(CLGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal != 0 && uint64(x) == uint64(y) => (First yes no)
(CLGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less != 0 && uint64(x) < uint64(y) => (First yes no)
(CLGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater != 0 && uint64(x) > uint64(y) => (First yes no)
(CLIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal != 0 && uint32(x) == uint32(y) => (First yes no)
(CLIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less != 0 && uint32(x) < uint32(y) => (First yes no)
(CLIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater != 0 && uint32(x) > uint32(y) => (First yes no)
(CGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal == 0 && int64(x) == int64(y) => (First no yes)
(CGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less == 0 && int64(x) < int64(y) => (First no yes)
(CGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater == 0 && int64(x) > int64(y) => (First no yes)
(CIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal == 0 && int32(x) == int32(y) => (First no yes)
(CIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less == 0 && int32(x) < int32(y) => (First no yes)
(CIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater == 0 && int32(x) > int32(y) => (First no yes)
(CLGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal == 0 && uint64(x) == uint64(y) => (First no yes)
(CLGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less == 0 && uint64(x) < uint64(y) => (First no yes)
(CLGIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater == 0 && uint64(x) > uint64(y) => (First no yes)
(CLIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Equal == 0 && uint32(x) == uint32(y) => (First no yes)
(CLIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Less == 0 && uint32(x) < uint32(y) => (First no yes)
(CLIJ [y] {c} (MOVDconst [x]) yes no) && c&s390x.Greater == 0 && uint32(x) > uint32(y) => (First no yes)
(C(L|LG)IJ [0] {s390x.GreaterOrEqual} _ yes no) => (First yes no)
(C(L|LG)IJ [0] {s390x.Less} _ yes no) => (First no yes)
(C(GR|R|LGR|LR)J {c} x y yes no) && x == y && c&s390x.Equal != 0 => (First yes no)
(C(GR|R|LGR|LR)J {c} x y yes no) && x == y && c&s390x.Equal == 0 => (First no yes)
(CM(P|PU)const [c] (MOV(W|WZ)reg x)) => (CMP(W|WU)const [c] x)
(CM(P|P|PU|PU)const [c] x:(MOV(H|HZ|H|HZ)reg _)) => (CMP(W|W|WU|WU)const [c] x)
(CM(P|P|PU|PU)const [c] x:(MOV(B|BZ|B|BZ)reg _)) => (CMP(W|W|WU|WU)const [c] x)
(CMPconst [c] (MOV(WZ|W)reg x:(ANDWconst [m] _))) && int32(m) >= 0 && c >= 0 => (CMPWUconst [c] x)
(CMPUconst [c] (MOV(WZ|W)reg x:(ANDWconst [m] _))) && int32(m) >= 0 => (CMPWUconst [c] x)
(CMPconst [n] x:(SRDconst [c] _)) && c > 0 && n >= 0 => (CMPUconst [n] x)
(CMPWconst [n] x:(SRWconst [c] _)) && c > 0 && n >= 0 => (CMPWUconst [n] x)
(CMP(W|W|WU|WU) x (MOV(W|WZ|W|WZ)reg y)) => (CMP(W|W|WU|WU) x y)
(CMP(W|W|WU|WU) (MOV(W|WZ|W|WZ)reg x) y) => (CMP(W|W|WU|WU) x y)
(CMP(W|W|WU|WU)const [c] (MOV(W|WZ|W|WZ)reg x)) => (CMP(W|W|WU|WU)const [c] x)
(BRC {c} (FlagEQ) yes no) && c&s390x.Equal != 0 => (First yes no)
(BRC {c} (FlagLT) yes no) && c&s390x.Less != 0 => (First yes no)
(BRC {c} (FlagGT) yes no) && c&s390x.Greater != 0 => (First yes no)
(BRC {c} (FlagOV) yes no) && c&s390x.Unordered != 0 => (First yes no)
(BRC {c} (FlagEQ) yes no) && c&s390x.Equal == 0 => (First no yes)
(BRC {c} (FlagLT) yes no) && c&s390x.Less == 0 => (First no yes)
(BRC {c} (FlagGT) yes no) && c&s390x.Greater == 0 => (First no yes)
(BRC {c} (FlagOV) yes no) && c&s390x.Unordered == 0 => (First no yes)
(LOCGR {c} _ x (FlagEQ)) && c&s390x.Equal != 0 => x
(LOCGR {c} _ x (FlagLT)) && c&s390x.Less != 0 => x
(LOCGR {c} _ x (FlagGT)) && c&s390x.Greater != 0 => x
(LOCGR {c} _ x (FlagOV)) && c&s390x.Unordered != 0 => x
(LOCGR {c} x _ (FlagEQ)) && c&s390x.Equal == 0 => x
(LOCGR {c} x _ (FlagLT)) && c&s390x.Less == 0 => x
(LOCGR {c} x _ (FlagGT)) && c&s390x.Greater == 0 => x
(LOCGR {c} x _ (FlagOV)) && c&s390x.Unordered == 0 => x
(ADDconst [0] x) => x
(ADDWconst [c] x) && int32(c) == 0 => x
(SUBconst [0] x) => x
(SUBWconst [c] x) && int32(c) == 0 => x
(ANDconst [0] _) => (MOVDconst [0])
(ANDWconst [c] _) && int32(c) == 0 => (MOVDconst [0])
(ANDconst [-1] x) => x
(ANDWconst [c] x) && int32(c) == -1 => x
(ORconst [0] x) => x
(ORWconst [c] x) && int32(c) == 0 => x
(ORconst [-1] _) => (MOVDconst [-1])
(ORWconst [c] _) && int32(c) == -1 => (MOVDconst [-1])
(XORconst [0] x) => x
(XORWconst [c] x) && int32(c) == 0 => x
((SLD|SLW|SRD|SRW|SRAD|SRAW)const [0] x) => x
(SUBconst [c] x) && c != -(1<<31) => (ADDconst [-c] x)
(SUBWconst [c] x) => (ADDWconst [-int32(c)] x)
(ADDconst [c] (MOVDconst [d])) => (MOVDconst [int64(c)+d])
(ADDWconst [c] (MOVDconst [d])) => (MOVDconst [int64(c)+d])
(ADDconst [c] (ADDconst [d] x)) && is32Bit(int64(c)+int64(d)) => (ADDconst [c+d] x)
(ADDWconst [c] (ADDWconst [d] x)) => (ADDWconst [int32(c+d)] x)
(SUBconst [c] (MOVDconst [d])) => (MOVDconst [d-int64(c)])
(SUBconst [c] (SUBconst [d] x)) && is32Bit(-int64(c)-int64(d)) => (ADDconst [-c-d] x)
(SRADconst [c] (MOVDconst [d])) => (MOVDconst [d>>uint64(c)])
(SRAWconst [c] (MOVDconst [d])) => (MOVDconst [int64(int32(d))>>uint64(c)])
(NEG (MOVDconst [c])) => (MOVDconst [-c])
(NEGW (MOVDconst [c])) => (MOVDconst [int64(int32(-c))])
(MULLDconst [c] (MOVDconst [d])) => (MOVDconst [int64(c)*d])
(MULLWconst [c] (MOVDconst [d])) => (MOVDconst [int64(c*int32(d))])
(AND (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c&d])
(ANDconst [c] (MOVDconst [d])) => (MOVDconst [c&d])
(ANDWconst [c] (MOVDconst [d])) => (MOVDconst [int64(c)&d])
(OR (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c|d])
(ORconst [c] (MOVDconst [d])) => (MOVDconst [c|d])
(ORWconst [c] (MOVDconst [d])) => (MOVDconst [int64(c)|d])
(XOR (MOVDconst [c]) (MOVDconst [d])) => (MOVDconst [c^d])
(XORconst [c] (MOVDconst [d])) => (MOVDconst [c^d])
(XORWconst [c] (MOVDconst [d])) => (MOVDconst [int64(c)^d])
(LoweredRound32F x:(FMOVSconst)) => x
(LoweredRound64F x:(FMOVDconst)) => x
(ADD x (NEG y)) => (SUB x y)
(ADDW x (NEGW y)) => (SUBW x y)
(SUB x x) => (MOVDconst [0])
(SUBW x x) => (MOVDconst [0])
(AND x x) => x
(ANDW x x) => x
(OR x x) => x
(ORW x x) => x
(XOR x x) => (MOVDconst [0])
(XORW x x) => (MOVDconst [0])
(NEG (ADDconst [c] (NEG x))) && c != -(1<<31) => (ADDconst [-c] x)
(MOVBZreg (ANDWconst [m] x)) => (MOVWZreg (ANDWconst <typ.UInt32> [int32(uint8(m))] x))
(MOVHZreg (ANDWconst [m] x)) => (MOVWZreg (ANDWconst <typ.UInt32> [int32(uint16(m))] x))
(MOVBreg (ANDWconst [m] x)) && int8(m) >= 0 => (MOVWZreg (ANDWconst <typ.UInt32> [int32(uint8(m))] x))
(MOVHreg (ANDWconst [m] x)) && int16(m) >= 0 => (MOVWZreg (ANDWconst <typ.UInt32> [int32(uint16(m))] x))
(Select1 (ADDCconst [d] (MOVDconst [c]))) && uint64(c+int64(d)) >= uint64(c) && c+int64(d) == 0 => (FlagEQ)
(Select1 (ADDCconst [d] (MOVDconst [c]))) && uint64(c+int64(d)) >= uint64(c) && c+int64(d) != 0 => (FlagLT)
(Select1 (SUBC (MOVDconst [c]) (MOVDconst [d]))) && uint64(d) <= uint64(c) && c-d == 0 => (FlagGT)
(Select1 (SUBC (MOVDconst [c]) (MOVDconst [d]))) && uint64(d) <= uint64(c) && c-d != 0 => (FlagOV)
(ADDE x y (FlagEQ)) => (ADDC x y)
(ADDE x y (FlagLT)) => (ADDC x y)
(ADDC x (MOVDconst [c])) && is16Bit(c) => (ADDCconst [int16(c)] x)
(Select0 (ADDCconst [d] (MOVDconst [c]))) => (MOVDconst [c+int64(d)])
(SUBE x y (FlagGT)) => (SUBC x y)
(SUBE x y (FlagOV)) => (SUBC x y)
(Select0 (SUBC (MOVDconst [c]) (MOVDconst [d]))) => (MOVDconst [c-d])
(ADDE x y (Select1 (ADDCconst [-1] (Select0 (ADDE (MOVDconst [0]) (MOVDconst [0]) c))))) => (ADDE x y c)
(SUBE x y (Select1 (SUBC (MOVDconst [0]) (NEG (Select0 (SUBE (MOVDconst [0]) (MOVDconst [0]) c)))))) => (SUBE x y c)
(C(G|LG)IJ [0] {s390x.Equal} (Select0 (ADDE (MOVDconst [0]) (MOVDconst [0]) carry))) => (BRC {s390x.NoCarry} carry)
(C(G|LG)IJ [1] {s390x.Equal} (Select0 (ADDE (MOVDconst [0]) (MOVDconst [0]) carry))) => (BRC {s390x.Carry} carry)
(C(G|LG)IJ [0] {s390x.LessOrGreater} (Select0 (ADDE (MOVDconst [0]) (MOVDconst [0]) carry))) => (BRC {s390x.Carry} carry)
(C(G|LG)IJ [1] {s390x.LessOrGreater} (Select0 (ADDE (MOVDconst [0]) (MOVDconst [0]) carry))) => (BRC {s390x.NoCarry} carry)
(C(G|LG)IJ [0] {s390x.Greater} (Select0 (ADDE (MOVDconst [0]) (MOVDconst [0]) carry))) => (BRC {s390x.Carry} carry)
(C(G|LG)IJ [0] {s390x.Equal} (NEG (Select0 (SUBE (MOVDconst [0]) (MOVDconst [0]) borrow)))) => (BRC {s390x.NoBorrow} borrow)
(C(G|LG)IJ [1] {s390x.Equal} (NEG (Select0 (SUBE (MOVDconst [0]) (MOVDconst [0]) borrow)))) => (BRC {s390x.Borrow} borrow)
(C(G|LG)IJ [0] {s390x.LessOrGreater} (NEG (Select0 (SUBE (MOVDconst [0]) (MOVDconst [0]) borrow)))) => (BRC {s390x.Borrow} borrow)
(C(G|LG)IJ [1] {s390x.LessOrGreater} (NEG (Select0 (SUBE (MOVDconst [0]) (MOVDconst [0]) borrow)))) => (BRC {s390x.NoBorrow} borrow)
(C(G|LG)IJ [0] {s390x.Greater} (NEG (Select0 (SUBE (MOVDconst [0]) (MOVDconst [0]) borrow)))) => (BRC {s390x.Borrow} borrow)
(Select0 (F(ADD|SUB) (FMUL y z) x)) => (FM(ADD|SUB) x y z)
(Select0 (F(ADDS|SUBS) (FMULS y z) x)) => (FM(ADDS|SUBS) x y z)
(F(CMP|CMPS) x (FMOV(D|S)const [0.0])) => (LT(D|E)BR x)
(F(CMP|CMPS) (FMOV(D|S)const [0.0]) x) => (InvertFlags (LT(D|E)BR <v.Type> x))
(LTDBR (Select0 x:(F(ADD|SUB) _ _))) && b == x.Block => (Select1 x)
(LTEBR (Select0 x:(F(ADDS|SUBS) _ _))) && b == x.Block => (Select1 x)
((ADD|SUB|MULLD|AND|OR|XOR) <t> x g:(MOVDload [off] {sym} ptr mem)) && ptr.Op != OpSB && is20Bit(int64(off)) && canMergeLoadClobber(v, g, x) && clobber(g) => ((ADD|SUB|MULLD|AND|OR|XOR)load <t> [off] {sym} x ptr mem)
((ADD|SUB|MULL|AND|OR|XOR)W <t> x g:(MOVWload [off] {sym} ptr mem)) && ptr.Op != OpSB && is20Bit(int64(off)) && canMergeLoadClobber(v, g, x) && clobber(g) => ((ADD|SUB|MULL|AND|OR|XOR)Wload <t> [off] {sym} x ptr mem)
((ADD|SUB|MULL|AND|OR|XOR)W <t> x g:(MOVWZload [off] {sym} ptr mem)) && ptr.Op != OpSB && is20Bit(int64(off)) && canMergeLoadClobber(v, g, x) && clobber(g) => ((ADD|SUB|MULL|AND|OR|XOR)Wload <t> [off] {sym} x ptr mem)
(MOVBstoreconst [c] {s} p x:(MOVBstoreconst [a] {s} p mem)) && p.Op != OpSB && x.Uses == 1 && a.Off()+1 == c.Off() && clobber(x) => (MOVHstoreconst [makeValAndOff32(c.Val32()&0xff|a.Val32()<<8, a.Off32())] {s} p mem)
(MOVHstoreconst [c] {s} p x:(MOVHstoreconst [a] {s} p mem)) && p.Op != OpSB && x.Uses == 1 && a.Off()+2 == c.Off() && clobber(x) => (MOVWstore [a.Off32()] {s} p (MOVDconst [int64(c.Val32()&0xffff|a.Val32()<<16)]) mem)
(MOVWstoreconst [c] {s} p x:(MOVWstoreconst [a] {s} p mem)) && p.Op != OpSB && x.Uses == 1 && a.Off()+4 == c.Off() && clobber(x) => (MOVDstore [a.Off32()] {s} p (MOVDconst [c.Val()&0xffffffff|a.Val()<<32]) mem)
(MOVBstore [i] {s} p w x:(MOVBstore [i-1] {s} p (SRDconst [8] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHstore [i-1] {s} p w mem)
(MOVBstore [i] {s} p w0:(SRDconst [j] w) x:(MOVBstore [i-1] {s} p (SRDconst [j+8] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHstore [i-1] {s} p w0 mem)
(MOVBstore [i] {s} p w x:(MOVBstore [i-1] {s} p (SRWconst [8] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHstore [i-1] {s} p w mem)
(MOVBstore [i] {s} p w0:(SRWconst [j] w) x:(MOVBstore [i-1] {s} p (SRWconst [j+8] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHstore [i-1] {s} p w0 mem)
(MOVHstore [i] {s} p w x:(MOVHstore [i-2] {s} p (SRDconst [16] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVWstore [i-2] {s} p w mem)
(MOVHstore [i] {s} p w0:(SRDconst [j] w) x:(MOVHstore [i-2] {s} p (SRDconst [j+16] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVWstore [i-2] {s} p w0 mem)
(MOVHstore [i] {s} p w x:(MOVHstore [i-2] {s} p (SRWconst [16] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVWstore [i-2] {s} p w mem)
(MOVHstore [i] {s} p w0:(SRWconst [j] w) x:(MOVHstore [i-2] {s} p (SRWconst [j+16] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVWstore [i-2] {s} p w0 mem)
(MOVWstore [i] {s} p (SRDconst [32] w) x:(MOVWstore [i-4] {s} p w mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVDstore [i-4] {s} p w mem)
(MOVWstore [i] {s} p w0:(SRDconst [j] w) x:(MOVWstore [i-4] {s} p (SRDconst [j+32] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVDstore [i-4] {s} p w0 mem)
(MOVBstore [i] {s} p (SRDconst [8] w) x:(MOVBstore [i-1] {s} p w mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHBRstore [i-1] {s} p w mem)
(MOVBstore [i] {s} p (SRDconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SRDconst [j-8] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHBRstore [i-1] {s} p w0 mem)
(MOVBstore [i] {s} p (SRWconst [8] w) x:(MOVBstore [i-1] {s} p w mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHBRstore [i-1] {s} p w mem)
(MOVBstore [i] {s} p (SRWconst [j] w) x:(MOVBstore [i-1] {s} p w0:(SRWconst [j-8] w) mem)) && p.Op != OpSB && x.Uses == 1 && clobber(x) => (MOVHBRstore [i-1] {s} p w0 mem)
(MOVHBRstore [i] {s} p (SRDconst [16] w) x:(MOVHBRstore [i-2] {s} p w mem)) && x.Uses == 1 && clobber(x) => (MOVWBRstore [i-2] {s} p w mem)
(MOVHBRstore [i] {s} p (SRDconst [j] w) x:(MOVHBRstore [i-2] {s} p w0:(SRDconst [j-16] w) mem)) && x.Uses == 1 && clobber(x) => (MOVWBRstore [i-2] {s} p w0 mem)
(MOVHBRstore [i] {s} p (SRWconst [16] w) x:(MOVHBRstore [i-2] {s} p w mem)) && x.Uses == 1 && clobber(x) => (MOVWBRstore [i-2] {s} p w mem)
(MOVHBRstore [i] {s} p (SRWconst [j] w) x:(MOVHBRstore [i-2] {s} p w0:(SRWconst [j-16] w) mem)) && x.Uses == 1 && clobber(x) => (MOVWBRstore [i-2] {s} p w0 mem)
(MOVWBRstore [i] {s} p (SRDconst [32] w) x:(MOVWBRstore [i-4] {s} p w mem)) && x.Uses == 1 && clobber(x) => (MOVDBRstore [i-4] {s} p w mem)
(MOVWBRstore [i] {s} p (SRDconst [j] w) x:(MOVWBRstore [i-4] {s} p w0:(SRDconst [j-32] w) mem)) && x.Uses == 1 && clobber(x) => (MOVDBRstore [i-4] {s} p w0 mem)
(ORW x1:(MOVBZload [i1] {s} p mem) sh:(SLWconst [8] x0:(MOVBZload [i0] {s} p mem))) && i1 == i0+1 && p.Op != OpSB && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, sh) => @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
(OR x1:(MOVBZload [i1] {s} p mem) sh:(SLDconst [8] x0:(MOVBZload [i0] {s} p mem))) && i1 == i0+1 && p.Op != OpSB && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, sh) => @mergePoint(b,x0,x1) (MOVHZload [i0] {s} p mem)
(ORW x1:(MOVHZload [i1] {s} p mem) sh:(SLWconst [16] x0:(MOVHZload [i0] {s} p mem))) && i1 == i0+2 && p.Op != OpSB && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, sh) => @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
(OR x1:(MOVHZload [i1] {s} p mem) sh:(SLDconst [16] x0:(MOVHZload [i0] {s} p mem))) && i1 == i0+2 && p.Op != OpSB && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, sh) => @mergePoint(b,x0,x1) (MOVWZload [i0] {s} p mem)
(OR x1:(MOVWZload [i1] {s} p mem) sh:(SLDconst [32] x0:(MOVWZload [i0] {s} p mem))) && i1 == i0+4 && p.Op != OpSB && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, sh) => @mergePoint(b,x0,x1) (MOVDload [i0] {s} p mem)
(ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) y)) && i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1, y) != nil && clobber(x0, x1, s0, s1, or) => @mergePoint(b,x0,x1,y) (ORW <v.Type> (SLWconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
(OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) y)) && i1 == i0+1 && j1 == j0-8 && j1%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1, y) != nil && clobber(x0, x1, s0, s1, or) => @mergePoint(b,x0,x1,y) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVHZload [i0] {s} p mem)) y)
(OR s0:(SLDconst [j0] x0:(MOVHZload [i0] {s} p mem)) or:(OR s1:(SLDconst [j1] x1:(MOVHZload [i1] {s} p mem)) y)) && i1 == i0+2 && j1 == j0-16 && j1%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1, y) != nil && clobber(x0, x1, s0, s1, or) => @mergePoint(b,x0,x1,y) (OR <v.Type> (SLDconst <v.Type> [j1] (MOVWZload [i0] {s} p mem)) y)
(ORW x0:(MOVBZload [i0] {s} p mem) sh:(SLWconst [8] x1:(MOVBZload [i1] {s} p mem))) && p.Op != OpSB && i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, sh) => @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
(OR x0:(MOVBZload [i0] {s} p mem) sh:(SLDconst [8] x1:(MOVBZload [i1] {s} p mem))) && p.Op != OpSB && i1 == i0+1 && x0.Uses == 1 && x1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, sh) => @mergePoint(b,x0,x1) (MOVHZreg (MOVHBRload [i0] {s} p mem))
(ORW r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)) sh:(SLWconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem)))) && i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, r0, r1, sh) => @mergePoint(b,x0,x1) (MOVWBRload [i0] {s} p mem)
(OR r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem)) sh:(SLDconst [16] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem)))) && i1 == i0+2 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, r0, r1, sh) => @mergePoint(b,x0,x1) (MOVWZreg (MOVWBRload [i0] {s} p mem))
(OR r0:(MOVWZreg x0:(MOVWBRload [i0] {s} p mem)) sh:(SLDconst [32] r1:(MOVWZreg x1:(MOVWBRload [i1] {s} p mem)))) && i1 == i0+4 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && sh.Uses == 1 && mergePoint(b, x0, x1) != nil && clobber(x0, x1, r0, r1, sh) => @mergePoint(b,x0,x1) (MOVDBRload [i0] {s} p mem)
(ORW s1:(SLWconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(ORW s0:(SLWconst [j0] x0:(MOVBZload [i0] {s} p mem)) y)) && p.Op != OpSB && i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1, y) != nil && clobber(x0, x1, s0, s1, or) => @mergePoint(b,x0,x1,y) (ORW <v.Type> (SLWconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
(OR s1:(SLDconst [j1] x1:(MOVBZload [i1] {s} p mem)) or:(OR s0:(SLDconst [j0] x0:(MOVBZload [i0] {s} p mem)) y)) && p.Op != OpSB && i1 == i0+1 && j1 == j0+8 && j0%16 == 0 && x0.Uses == 1 && x1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1, y) != nil && clobber(x0, x1, s0, s1, or) => @mergePoint(b,x0,x1,y) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVHZreg (MOVHBRload [i0] {s} p mem))) y)
(OR s1:(SLDconst [j1] r1:(MOVHZreg x1:(MOVHBRload [i1] {s} p mem))) or:(OR s0:(SLDconst [j0] r0:(MOVHZreg x0:(MOVHBRload [i0] {s} p mem))) y)) && i1 == i0+2 && j1 == j0+16 && j0%32 == 0 && x0.Uses == 1 && x1.Uses == 1 && r0.Uses == 1 && r1.Uses == 1 && s0.Uses == 1 && s1.Uses == 1 && or.Uses == 1 && mergePoint(b, x0, x1, y) != nil && clobber(x0, x1, r0, r1, s0, s1, or) => @mergePoint(b,x0,x1,y) (OR <v.Type> (SLDconst <v.Type> [j0] (MOVWZreg (MOVWBRload [i0] {s} p mem))) y)
(MOVWstore [i] {s} p w1 x:(MOVWstore [i-4] {s} p w0 mem)) && p.Op != OpSB && x.Uses == 1 && is20Bit(int64(i)-4) && clobber(x) => (STM2 [i-4] {s} p w0 w1 mem)
(MOVWstore [i] {s} p w2 x:(STM2 [i-8] {s} p w0 w1 mem)) && x.Uses == 1 && is20Bit(int64(i)-8) && clobber(x) => (STM3 [i-8] {s} p w0 w1 w2 mem)
(MOVWstore [i] {s} p w3 x:(STM3 [i-12] {s} p w0 w1 w2 mem)) && x.Uses == 1 && is20Bit(int64(i)-12) && clobber(x) => (STM4 [i-12] {s} p w0 w1 w2 w3 mem)
(STM2 [i] {s} p w2 w3 x:(STM2 [i-8] {s} p w0 w1 mem)) && x.Uses == 1 && is20Bit(int64(i)-8) && clobber(x) => (STM4 [i-8] {s} p w0 w1 w2 w3 mem)
(MOVDstore [i] {s} p w1 x:(MOVDstore [i-8] {s} p w0 mem)) && p.Op != OpSB && x.Uses == 1 && is20Bit(int64(i)-8) && clobber(x) => (STMG2 [i-8] {s} p w0 w1 mem)
(MOVDstore [i] {s} p w2 x:(STMG2 [i-16] {s} p w0 w1 mem)) && x.Uses == 1 && is20Bit(int64(i)-16) && clobber(x) => (STMG3 [i-16] {s} p w0 w1 w2 mem)
(MOVDstore [i] {s} p w3 x:(STMG3 [i-24] {s} p w0 w1 w2 mem)) && x.Uses == 1 && is20Bit(int64(i)-24) && clobber(x) => (STMG4 [i-24] {s} p w0 w1 w2 w3 mem)
(STMG2 [i] {s} p w2 w3 x:(STMG2 [i-16] {s} p w0 w1 mem)) && x.Uses == 1 && is20Bit(int64(i)-16) && clobber(x) => (STMG4 [i-16] {s} p w0 w1 w2 w3 mem)
(STM2 [i] {s} p (SRDconst [32] x) x mem) => (MOVDstore [i] {s} p x mem)
