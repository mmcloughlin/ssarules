(Arg [off] {n}) && v.Type.IsString() => (StringMake (Arg <typ.BytePtr> [off] {n}) (Arg <typ.Int> [off+int32(config.PtrSize)] {n}))
(Arg [off] {n}) && v.Type.IsSlice() => (SliceMake (Arg <v.Type.Elem().PtrTo()> [off] {n}) (Arg <typ.Int> [off+int32(config.PtrSize)] {n}) (Arg <typ.Int> [off+2*int32(config.PtrSize)] {n}))
(Arg [off] {n}) && v.Type.IsInterface() => (IMake (Arg <typ.Uintptr> [off] {n}) (Arg <typ.BytePtr> [off+int32(config.PtrSize)] {n}))
(Arg [off] {n}) && v.Type.IsComplex() && v.Type.Size() == 16 => (ComplexMake (Arg <typ.Float64> [off] {n}) (Arg <typ.Float64> [off+8] {n}))
(Arg [off] {n}) && v.Type.IsComplex() && v.Type.Size() == 8 => (ComplexMake (Arg <typ.Float32> [off] {n}) (Arg <typ.Float32> [off+4] {n}))
(Arg <t>) && t.IsStruct() && t.NumFields() == 0 && fe.CanSSA(t) => (StructMake0)
(Arg <t> [off] {n}) && t.IsStruct() && t.NumFields() == 1 && fe.CanSSA(t) => (StructMake1 (Arg <t.FieldType(0)> [off+int32(t.FieldOff(0))] {n}))
(Arg <t> [off] {n}) && t.IsStruct() && t.NumFields() == 2 && fe.CanSSA(t) => (StructMake2 (Arg <t.FieldType(0)> [off+int32(t.FieldOff(0))] {n}) (Arg <t.FieldType(1)> [off+int32(t.FieldOff(1))] {n}))
(Arg <t> [off] {n}) && t.IsStruct() && t.NumFields() == 3 && fe.CanSSA(t) => (StructMake3 (Arg <t.FieldType(0)> [off+int32(t.FieldOff(0))] {n}) (Arg <t.FieldType(1)> [off+int32(t.FieldOff(1))] {n}) (Arg <t.FieldType(2)> [off+int32(t.FieldOff(2))] {n}))
(Arg <t> [off] {n}) && t.IsStruct() && t.NumFields() == 4 && fe.CanSSA(t) => (StructMake4 (Arg <t.FieldType(0)> [off+int32(t.FieldOff(0))] {n}) (Arg <t.FieldType(1)> [off+int32(t.FieldOff(1))] {n}) (Arg <t.FieldType(2)> [off+int32(t.FieldOff(2))] {n}) (Arg <t.FieldType(3)> [off+int32(t.FieldOff(3))] {n}))
(Arg <t>) && t.IsArray() && t.NumElem() == 0 => (ArrayMake0)
(Arg <t> [off] {n}) && t.IsArray() && t.NumElem() == 1 && fe.CanSSA(t) => (ArrayMake1 (Arg <t.Elem()> [off] {n}))
